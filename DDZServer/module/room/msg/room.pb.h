// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: room.proto

#ifndef PROTOBUF_room_2eproto__INCLUDED
#define PROTOBUF_room_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace zhu {
namespace room {
class CreateRoomReq;
class CreateRoomReqDefaultTypeInternal;
extern CreateRoomReqDefaultTypeInternal _CreateRoomReq_default_instance_;
class CreateRoomResp;
class CreateRoomRespDefaultTypeInternal;
extern CreateRoomRespDefaultTypeInternal _CreateRoomResp_default_instance_;
class EnterRoomReq;
class EnterRoomReqDefaultTypeInternal;
extern EnterRoomReqDefaultTypeInternal _EnterRoomReq_default_instance_;
class EnterRoomResp;
class EnterRoomRespDefaultTypeInternal;
extern EnterRoomRespDefaultTypeInternal _EnterRoomResp_default_instance_;
class GameOverMsg;
class GameOverMsgDefaultTypeInternal;
extern GameOverMsgDefaultTypeInternal _GameOverMsg_default_instance_;
class GetRoomReq;
class GetRoomReqDefaultTypeInternal;
extern GetRoomReqDefaultTypeInternal _GetRoomReq_default_instance_;
class GetRoomResp;
class GetRoomRespDefaultTypeInternal;
extern GetRoomRespDefaultTypeInternal _GetRoomResp_default_instance_;
class LeaveRoomReq;
class LeaveRoomReqDefaultTypeInternal;
extern LeaveRoomReqDefaultTypeInternal _LeaveRoomReq_default_instance_;
class LeaveRoomResp;
class LeaveRoomRespDefaultTypeInternal;
extern LeaveRoomRespDefaultTypeInternal _LeaveRoomResp_default_instance_;
class ReadyReq;
class ReadyReqDefaultTypeInternal;
extern ReadyReqDefaultTypeInternal _ReadyReq_default_instance_;
class ReadyResp;
class ReadyRespDefaultTypeInternal;
extern ReadyRespDefaultTypeInternal _ReadyResp_default_instance_;
class Room;
class RoomDefaultTypeInternal;
extern RoomDefaultTypeInternal _Room_default_instance_;
class RoomGameStatuChangeNotify;
class RoomGameStatuChangeNotifyDefaultTypeInternal;
extern RoomGameStatuChangeNotifyDefaultTypeInternal _RoomGameStatuChangeNotify_default_instance_;
class RoomUserCountChangeNotify;
class RoomUserCountChangeNotifyDefaultTypeInternal;
extern RoomUserCountChangeNotifyDefaultTypeInternal _RoomUserCountChangeNotify_default_instance_;
class Seat;
class SeatDefaultTypeInternal;
extern SeatDefaultTypeInternal _Seat_default_instance_;
}  // namespace room
}  // namespace zhu

namespace zhu {
namespace room {

namespace protobuf_room_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_room_2eproto

enum Seat_SeatStatus {
  Seat_SeatStatus_UNREADY = 0,
  Seat_SeatStatus_READY = 1,
  Seat_SeatStatus_NO_PLAYER = 2
};
bool Seat_SeatStatus_IsValid(int value);
const Seat_SeatStatus Seat_SeatStatus_SeatStatus_MIN = Seat_SeatStatus_UNREADY;
const Seat_SeatStatus Seat_SeatStatus_SeatStatus_MAX = Seat_SeatStatus_NO_PLAYER;
const int Seat_SeatStatus_SeatStatus_ARRAYSIZE = Seat_SeatStatus_SeatStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* Seat_SeatStatus_descriptor();
inline const ::std::string& Seat_SeatStatus_Name(Seat_SeatStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    Seat_SeatStatus_descriptor(), value);
}
inline bool Seat_SeatStatus_Parse(
    const ::std::string& name, Seat_SeatStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Seat_SeatStatus>(
    Seat_SeatStatus_descriptor(), name, value);
}
enum RoomStatus {
  WAIT = 0,
  DESTORYE = 1,
  START = 2,
  FULL = 3
};
bool RoomStatus_IsValid(int value);
const RoomStatus RoomStatus_MIN = WAIT;
const RoomStatus RoomStatus_MAX = FULL;
const int RoomStatus_ARRAYSIZE = RoomStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomStatus_descriptor();
inline const ::std::string& RoomStatus_Name(RoomStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomStatus_descriptor(), value);
}
inline bool RoomStatus_Parse(
    const ::std::string& name, RoomStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomStatus>(
    RoomStatus_descriptor(), name, value);
}
enum ERROR_CODE {
  SUCCESS = 0,
  ROOM_NOT_EXIST = 1,
  ROOM_USER_FULL_ERROR = 2,
  CREATE_ROOM_ERROR = 3,
  PLAYER_NOT_IN_ROOM = 4,
  PLAYER_HAS_IN_ROOM = 5,
  PLAYER_HAS_READY = 6,
  SERVER_ERROR = 7
};
bool ERROR_CODE_IsValid(int value);
const ERROR_CODE ERROR_CODE_MIN = SUCCESS;
const ERROR_CODE ERROR_CODE_MAX = SERVER_ERROR;
const int ERROR_CODE_ARRAYSIZE = ERROR_CODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERROR_CODE_descriptor();
inline const ::std::string& ERROR_CODE_Name(ERROR_CODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERROR_CODE_descriptor(), value);
}
inline bool ERROR_CODE_Parse(
    const ::std::string& name, ERROR_CODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERROR_CODE>(
    ERROR_CODE_descriptor(), name, value);
}
// ===================================================================

class Seat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.Seat) */ {
 public:
  Seat();
  virtual ~Seat();

  Seat(const Seat& from);

  inline Seat& operator=(const Seat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Seat& default_instance();

  static inline const Seat* internal_default_instance() {
    return reinterpret_cast<const Seat*>(
               &_Seat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Seat* other);

  // implements Message ----------------------------------------------

  inline Seat* New() const PROTOBUF_FINAL { return New(NULL); }

  Seat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Seat& from);
  void MergeFrom(const Seat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Seat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Seat_SeatStatus SeatStatus;
  static const SeatStatus UNREADY =
    Seat_SeatStatus_UNREADY;
  static const SeatStatus READY =
    Seat_SeatStatus_READY;
  static const SeatStatus NO_PLAYER =
    Seat_SeatStatus_NO_PLAYER;
  static inline bool SeatStatus_IsValid(int value) {
    return Seat_SeatStatus_IsValid(value);
  }
  static const SeatStatus SeatStatus_MIN =
    Seat_SeatStatus_SeatStatus_MIN;
  static const SeatStatus SeatStatus_MAX =
    Seat_SeatStatus_SeatStatus_MAX;
  static const int SeatStatus_ARRAYSIZE =
    Seat_SeatStatus_SeatStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SeatStatus_descriptor() {
    return Seat_SeatStatus_descriptor();
  }
  static inline const ::std::string& SeatStatus_Name(SeatStatus value) {
    return Seat_SeatStatus_Name(value);
  }
  static inline bool SeatStatus_Parse(const ::std::string& name,
      SeatStatus* value) {
    return Seat_SeatStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes playerAccount = 4;
  bool has_playeraccount() const;
  void clear_playeraccount();
  static const int kPlayerAccountFieldNumber = 4;
  const ::std::string& playeraccount() const;
  void set_playeraccount(const ::std::string& value);
  #if LANG_CXX11
  void set_playeraccount(::std::string&& value);
  #endif
  void set_playeraccount(const char* value);
  void set_playeraccount(const void* value, size_t size);
  ::std::string* mutable_playeraccount();
  ::std::string* release_playeraccount();
  void set_allocated_playeraccount(::std::string* playeraccount);

  // required uint32 position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // optional int32 socket = 3;
  bool has_socket() const;
  void clear_socket();
  static const int kSocketFieldNumber = 3;
  ::google::protobuf::int32 socket() const;
  void set_socket(::google::protobuf::int32 value);

  // required .zhu.room.Seat.SeatStatus statu = 1 [default = NO_PLAYER];
  bool has_statu() const;
  void clear_statu();
  static const int kStatuFieldNumber = 1;
  ::zhu::room::Seat_SeatStatus statu() const;
  void set_statu(::zhu::room::Seat_SeatStatus value);

  // @@protoc_insertion_point(class_scope:zhu.room.Seat)
 private:
  void set_has_statu();
  void clear_has_statu();
  void set_has_position();
  void clear_has_position();
  void set_has_socket();
  void clear_has_socket();
  void set_has_playeraccount();
  void clear_has_playeraccount();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr playeraccount_;
  ::google::protobuf::uint32 position_;
  ::google::protobuf::int32 socket_;
  int statu_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Room : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.Room) */ {
 public:
  Room();
  virtual ~Room();

  Room(const Room& from);

  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room& default_instance();

  static inline const Room* internal_default_instance() {
    return reinterpret_cast<const Room*>(
               &_Room_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Room* other);

  // implements Message ----------------------------------------------

  inline Room* New() const PROTOBUF_FINAL { return New(NULL); }

  Room* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Room& from);
  void MergeFrom(const Room& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Room* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes roomName = 2;
  bool has_roomname() const;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const void* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // optional .zhu.room.Seat seat1 = 5;
  bool has_seat1() const;
  void clear_seat1();
  static const int kSeat1FieldNumber = 5;
  const ::zhu::room::Seat& seat1() const;
  ::zhu::room::Seat* mutable_seat1();
  ::zhu::room::Seat* release_seat1();
  void set_allocated_seat1(::zhu::room::Seat* seat1);

  // optional .zhu.room.Seat seat2 = 6;
  bool has_seat2() const;
  void clear_seat2();
  static const int kSeat2FieldNumber = 6;
  const ::zhu::room::Seat& seat2() const;
  ::zhu::room::Seat* mutable_seat2();
  ::zhu::room::Seat* release_seat2();
  void set_allocated_seat2(::zhu::room::Seat* seat2);

  // optional .zhu.room.Seat seat3 = 7;
  bool has_seat3() const;
  void clear_seat3();
  static const int kSeat3FieldNumber = 7;
  const ::zhu::room::Seat& seat3() const;
  ::zhu::room::Seat* mutable_seat3();
  ::zhu::room::Seat* release_seat3();
  void set_allocated_seat3(::zhu::room::Seat* seat3);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required uint32 userCount = 3;
  bool has_usercount() const;
  void clear_usercount();
  static const int kUserCountFieldNumber = 3;
  ::google::protobuf::uint32 usercount() const;
  void set_usercount(::google::protobuf::uint32 value);

  // optional .zhu.room.RoomStatus status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::zhu::room::RoomStatus status() const;
  void set_status(::zhu::room::RoomStatus value);

  // @@protoc_insertion_point(class_scope:zhu.room.Room)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_roomname();
  void clear_has_roomname();
  void set_has_usercount();
  void clear_has_usercount();
  void set_has_status();
  void clear_has_status();
  void set_has_seat1();
  void clear_has_seat1();
  void set_has_seat2();
  void clear_has_seat2();
  void set_has_seat3();
  void clear_has_seat3();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  ::zhu::room::Seat* seat1_;
  ::zhu::room::Seat* seat2_;
  ::zhu::room::Seat* seat3_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 usercount_;
  int status_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRoomReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.GetRoomReq) */ {
 public:
  GetRoomReq();
  virtual ~GetRoomReq();

  GetRoomReq(const GetRoomReq& from);

  inline GetRoomReq& operator=(const GetRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoomReq& default_instance();

  static inline const GetRoomReq* internal_default_instance() {
    return reinterpret_cast<const GetRoomReq*>(
               &_GetRoomReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GetRoomReq* other);

  // implements Message ----------------------------------------------

  inline GetRoomReq* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRoomReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRoomReq& from);
  void MergeFrom(const GetRoomReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRoomReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:zhu.room.GetRoomReq)
 private:
  void set_has_account();
  void clear_has_account();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRoomResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.GetRoomResp) */ {
 public:
  GetRoomResp();
  virtual ~GetRoomResp();

  GetRoomResp(const GetRoomResp& from);

  inline GetRoomResp& operator=(const GetRoomResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoomResp& default_instance();

  static inline const GetRoomResp* internal_default_instance() {
    return reinterpret_cast<const GetRoomResp*>(
               &_GetRoomResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GetRoomResp* other);

  // implements Message ----------------------------------------------

  inline GetRoomResp* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRoomResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRoomResp& from);
  void MergeFrom(const GetRoomResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRoomResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zhu.room.Room room = 2;
  int room_size() const;
  void clear_room();
  static const int kRoomFieldNumber = 2;
  const ::zhu::room::Room& room(int index) const;
  ::zhu::room::Room* mutable_room(int index);
  ::zhu::room::Room* add_room();
  ::google::protobuf::RepeatedPtrField< ::zhu::room::Room >*
      mutable_room();
  const ::google::protobuf::RepeatedPtrField< ::zhu::room::Room >&
      room() const;

  // required uint32 count = 1;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhu.room.GetRoomResp)
 private:
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zhu::room::Room > room_;
  ::google::protobuf::uint32 count_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaveRoomReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.LeaveRoomReq) */ {
 public:
  LeaveRoomReq();
  virtual ~LeaveRoomReq();

  LeaveRoomReq(const LeaveRoomReq& from);

  inline LeaveRoomReq& operator=(const LeaveRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveRoomReq& default_instance();

  static inline const LeaveRoomReq* internal_default_instance() {
    return reinterpret_cast<const LeaveRoomReq*>(
               &_LeaveRoomReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LeaveRoomReq* other);

  // implements Message ----------------------------------------------

  inline LeaveRoomReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LeaveRoomReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeaveRoomReq& from);
  void MergeFrom(const LeaveRoomReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeaveRoomReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // required uint32 roomId = 2;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhu.room.LeaveRoomReq)
 private:
  void set_has_account();
  void clear_has_account();
  void set_has_roomid();
  void clear_has_roomid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::uint32 roomid_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaveRoomResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.LeaveRoomResp) */ {
 public:
  LeaveRoomResp();
  virtual ~LeaveRoomResp();

  LeaveRoomResp(const LeaveRoomResp& from);

  inline LeaveRoomResp& operator=(const LeaveRoomResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveRoomResp& default_instance();

  static inline const LeaveRoomResp* internal_default_instance() {
    return reinterpret_cast<const LeaveRoomResp*>(
               &_LeaveRoomResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(LeaveRoomResp* other);

  // implements Message ----------------------------------------------

  inline LeaveRoomResp* New() const PROTOBUF_FINAL { return New(NULL); }

  LeaveRoomResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeaveRoomResp& from);
  void MergeFrom(const LeaveRoomResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeaveRoomResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .zhu.room.ERROR_CODE leaveRoomResult = 1;
  bool has_leaveroomresult() const;
  void clear_leaveroomresult();
  static const int kLeaveRoomResultFieldNumber = 1;
  ::zhu::room::ERROR_CODE leaveroomresult() const;
  void set_leaveroomresult(::zhu::room::ERROR_CODE value);

  // @@protoc_insertion_point(class_scope:zhu.room.LeaveRoomResp)
 private:
  void set_has_leaveroomresult();
  void clear_has_leaveroomresult();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int leaveroomresult_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnterRoomReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.EnterRoomReq) */ {
 public:
  EnterRoomReq();
  virtual ~EnterRoomReq();

  EnterRoomReq(const EnterRoomReq& from);

  inline EnterRoomReq& operator=(const EnterRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomReq& default_instance();

  static inline const EnterRoomReq* internal_default_instance() {
    return reinterpret_cast<const EnterRoomReq*>(
               &_EnterRoomReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(EnterRoomReq* other);

  // implements Message ----------------------------------------------

  inline EnterRoomReq* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterRoomReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterRoomReq& from);
  void MergeFrom(const EnterRoomReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterRoomReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // required uint32 roomId = 2;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhu.room.EnterRoomReq)
 private:
  void set_has_account();
  void clear_has_account();
  void set_has_roomid();
  void clear_has_roomid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::uint32 roomid_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnterRoomResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.EnterRoomResp) */ {
 public:
  EnterRoomResp();
  virtual ~EnterRoomResp();

  EnterRoomResp(const EnterRoomResp& from);

  inline EnterRoomResp& operator=(const EnterRoomResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoomResp& default_instance();

  static inline const EnterRoomResp* internal_default_instance() {
    return reinterpret_cast<const EnterRoomResp*>(
               &_EnterRoomResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(EnterRoomResp* other);

  // implements Message ----------------------------------------------

  inline EnterRoomResp* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterRoomResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterRoomResp& from);
  void MergeFrom(const EnterRoomResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterRoomResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes desc = 3;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 3;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // optional .zhu.room.Room roomInfo = 2;
  bool has_roominfo() const;
  void clear_roominfo();
  static const int kRoomInfoFieldNumber = 2;
  const ::zhu::room::Room& roominfo() const;
  ::zhu::room::Room* mutable_roominfo();
  ::zhu::room::Room* release_roominfo();
  void set_allocated_roominfo(::zhu::room::Room* roominfo);

  // required .zhu.room.ERROR_CODE enterResult = 1;
  bool has_enterresult() const;
  void clear_enterresult();
  static const int kEnterResultFieldNumber = 1;
  ::zhu::room::ERROR_CODE enterresult() const;
  void set_enterresult(::zhu::room::ERROR_CODE value);

  // optional uint32 position = 4;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 4;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhu.room.EnterRoomResp)
 private:
  void set_has_enterresult();
  void clear_has_enterresult();
  void set_has_roominfo();
  void clear_has_roominfo();
  void set_has_desc();
  void clear_has_desc();
  void set_has_position();
  void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::zhu::room::Room* roominfo_;
  int enterresult_;
  ::google::protobuf::uint32 position_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateRoomReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.CreateRoomReq) */ {
 public:
  CreateRoomReq();
  virtual ~CreateRoomReq();

  CreateRoomReq(const CreateRoomReq& from);

  inline CreateRoomReq& operator=(const CreateRoomReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomReq& default_instance();

  static inline const CreateRoomReq* internal_default_instance() {
    return reinterpret_cast<const CreateRoomReq*>(
               &_CreateRoomReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CreateRoomReq* other);

  // implements Message ----------------------------------------------

  inline CreateRoomReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoomReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoomReq& from);
  void MergeFrom(const CreateRoomReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoomReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:zhu.room.CreateRoomReq)
 private:
  void set_has_account();
  void clear_has_account();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateRoomResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.CreateRoomResp) */ {
 public:
  CreateRoomResp();
  virtual ~CreateRoomResp();

  CreateRoomResp(const CreateRoomResp& from);

  inline CreateRoomResp& operator=(const CreateRoomResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomResp& default_instance();

  static inline const CreateRoomResp* internal_default_instance() {
    return reinterpret_cast<const CreateRoomResp*>(
               &_CreateRoomResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CreateRoomResp* other);

  // implements Message ----------------------------------------------

  inline CreateRoomResp* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoomResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoomResp& from);
  void MergeFrom(const CreateRoomResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoomResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // optional .zhu.room.Room createRoom = 3;
  bool has_createroom() const;
  void clear_createroom();
  static const int kCreateRoomFieldNumber = 3;
  const ::zhu::room::Room& createroom() const;
  ::zhu::room::Room* mutable_createroom();
  ::zhu::room::Room* release_createroom();
  void set_allocated_createroom(::zhu::room::Room* createroom);

  // required .zhu.room.ERROR_CODE createResult = 1;
  bool has_createresult() const;
  void clear_createresult();
  static const int kCreateResultFieldNumber = 1;
  ::zhu::room::ERROR_CODE createresult() const;
  void set_createresult(::zhu::room::ERROR_CODE value);

  // @@protoc_insertion_point(class_scope:zhu.room.CreateRoomResp)
 private:
  void set_has_createresult();
  void clear_has_createresult();
  void set_has_desc();
  void clear_has_desc();
  void set_has_createroom();
  void clear_has_createroom();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::zhu::room::Room* createroom_;
  int createresult_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadyReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.ReadyReq) */ {
 public:
  ReadyReq();
  virtual ~ReadyReq();

  ReadyReq(const ReadyReq& from);

  inline ReadyReq& operator=(const ReadyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadyReq& default_instance();

  static inline const ReadyReq* internal_default_instance() {
    return reinterpret_cast<const ReadyReq*>(
               &_ReadyReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ReadyReq* other);

  // implements Message ----------------------------------------------

  inline ReadyReq* New() const PROTOBUF_FINAL { return New(NULL); }

  ReadyReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReadyReq& from);
  void MergeFrom(const ReadyReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReadyReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // required uint32 roomid = 2;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomidFieldNumber = 2;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // required bool ready = 3;
  bool has_ready() const;
  void clear_ready();
  static const int kReadyFieldNumber = 3;
  bool ready() const;
  void set_ready(bool value);

  // @@protoc_insertion_point(class_scope:zhu.room.ReadyReq)
 private:
  void set_has_account();
  void clear_has_account();
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_ready();
  void clear_has_ready();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::uint32 roomid_;
  bool ready_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadyResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.ReadyResp) */ {
 public:
  ReadyResp();
  virtual ~ReadyResp();

  ReadyResp(const ReadyResp& from);

  inline ReadyResp& operator=(const ReadyResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadyResp& default_instance();

  static inline const ReadyResp* internal_default_instance() {
    return reinterpret_cast<const ReadyResp*>(
               &_ReadyResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ReadyResp* other);

  // implements Message ----------------------------------------------

  inline ReadyResp* New() const PROTOBUF_FINAL { return New(NULL); }

  ReadyResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReadyResp& from);
  void MergeFrom(const ReadyResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReadyResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes account = 2;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // optional bytes desc = 5;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 5;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // required .zhu.room.ERROR_CODE readyResult = 1;
  bool has_readyresult() const;
  void clear_readyresult();
  static const int kReadyResultFieldNumber = 1;
  ::zhu::room::ERROR_CODE readyresult() const;
  void set_readyresult(::zhu::room::ERROR_CODE value);

  // optional uint32 position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // optional bool ready = 4;
  bool has_ready() const;
  void clear_ready();
  static const int kReadyFieldNumber = 4;
  bool ready() const;
  void set_ready(bool value);

  // @@protoc_insertion_point(class_scope:zhu.room.ReadyResp)
 private:
  void set_has_readyresult();
  void clear_has_readyresult();
  void set_has_account();
  void clear_has_account();
  void set_has_position();
  void clear_has_position();
  void set_has_ready();
  void clear_has_ready();
  void set_has_desc();
  void clear_has_desc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  int readyresult_;
  ::google::protobuf::uint32 position_;
  bool ready_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameOverMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.GameOverMsg) */ {
 public:
  GameOverMsg();
  virtual ~GameOverMsg();

  GameOverMsg(const GameOverMsg& from);

  inline GameOverMsg& operator=(const GameOverMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameOverMsg& default_instance();

  static inline const GameOverMsg* internal_default_instance() {
    return reinterpret_cast<const GameOverMsg*>(
               &_GameOverMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(GameOverMsg* other);

  // implements Message ----------------------------------------------

  inline GameOverMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  GameOverMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameOverMsg& from);
  void MergeFrom(const GameOverMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameOverMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes winFirstAccount = 2;
  bool has_winfirstaccount() const;
  void clear_winfirstaccount();
  static const int kWinFirstAccountFieldNumber = 2;
  const ::std::string& winfirstaccount() const;
  void set_winfirstaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_winfirstaccount(::std::string&& value);
  #endif
  void set_winfirstaccount(const char* value);
  void set_winfirstaccount(const void* value, size_t size);
  ::std::string* mutable_winfirstaccount();
  ::std::string* release_winfirstaccount();
  void set_allocated_winfirstaccount(::std::string* winfirstaccount);

  // optional bytes winSecondAccount = 3;
  bool has_winsecondaccount() const;
  void clear_winsecondaccount();
  static const int kWinSecondAccountFieldNumber = 3;
  const ::std::string& winsecondaccount() const;
  void set_winsecondaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_winsecondaccount(::std::string&& value);
  #endif
  void set_winsecondaccount(const char* value);
  void set_winsecondaccount(const void* value, size_t size);
  ::std::string* mutable_winsecondaccount();
  ::std::string* release_winsecondaccount();
  void set_allocated_winsecondaccount(::std::string* winsecondaccount);

  // optional bytes loseFirstAccount = 4;
  bool has_losefirstaccount() const;
  void clear_losefirstaccount();
  static const int kLoseFirstAccountFieldNumber = 4;
  const ::std::string& losefirstaccount() const;
  void set_losefirstaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_losefirstaccount(::std::string&& value);
  #endif
  void set_losefirstaccount(const char* value);
  void set_losefirstaccount(const void* value, size_t size);
  ::std::string* mutable_losefirstaccount();
  ::std::string* release_losefirstaccount();
  void set_allocated_losefirstaccount(::std::string* losefirstaccount);

  // optional bytes loseSecondAccount = 5;
  bool has_losesecondaccount() const;
  void clear_losesecondaccount();
  static const int kLoseSecondAccountFieldNumber = 5;
  const ::std::string& losesecondaccount() const;
  void set_losesecondaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_losesecondaccount(::std::string&& value);
  #endif
  void set_losesecondaccount(const char* value);
  void set_losesecondaccount(const void* value, size_t size);
  ::std::string* mutable_losesecondaccount();
  ::std::string* release_losesecondaccount();
  void set_allocated_losesecondaccount(::std::string* losesecondaccount);

  // required uint32 roomid = 1;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomidFieldNumber = 1;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhu.room.GameOverMsg)
 private:
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_winfirstaccount();
  void clear_has_winfirstaccount();
  void set_has_winsecondaccount();
  void clear_has_winsecondaccount();
  void set_has_losefirstaccount();
  void clear_has_losefirstaccount();
  void set_has_losesecondaccount();
  void clear_has_losesecondaccount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr winfirstaccount_;
  ::google::protobuf::internal::ArenaStringPtr winsecondaccount_;
  ::google::protobuf::internal::ArenaStringPtr losefirstaccount_;
  ::google::protobuf::internal::ArenaStringPtr losesecondaccount_;
  ::google::protobuf::uint32 roomid_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomUserCountChangeNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.RoomUserCountChangeNotify) */ {
 public:
  RoomUserCountChangeNotify();
  virtual ~RoomUserCountChangeNotify();

  RoomUserCountChangeNotify(const RoomUserCountChangeNotify& from);

  inline RoomUserCountChangeNotify& operator=(const RoomUserCountChangeNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomUserCountChangeNotify& default_instance();

  static inline const RoomUserCountChangeNotify* internal_default_instance() {
    return reinterpret_cast<const RoomUserCountChangeNotify*>(
               &_RoomUserCountChangeNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(RoomUserCountChangeNotify* other);

  // implements Message ----------------------------------------------

  inline RoomUserCountChangeNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  RoomUserCountChangeNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoomUserCountChangeNotify& from);
  void MergeFrom(const RoomUserCountChangeNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoomUserCountChangeNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required uint32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhu.room.RoomUserCountChangeNotify)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_count();
  void clear_has_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 count_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomGameStatuChangeNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.room.RoomGameStatuChangeNotify) */ {
 public:
  RoomGameStatuChangeNotify();
  virtual ~RoomGameStatuChangeNotify();

  RoomGameStatuChangeNotify(const RoomGameStatuChangeNotify& from);

  inline RoomGameStatuChangeNotify& operator=(const RoomGameStatuChangeNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomGameStatuChangeNotify& default_instance();

  static inline const RoomGameStatuChangeNotify* internal_default_instance() {
    return reinterpret_cast<const RoomGameStatuChangeNotify*>(
               &_RoomGameStatuChangeNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(RoomGameStatuChangeNotify* other);

  // implements Message ----------------------------------------------

  inline RoomGameStatuChangeNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  RoomGameStatuChangeNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoomGameStatuChangeNotify& from);
  void MergeFrom(const RoomGameStatuChangeNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoomGameStatuChangeNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required bool start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  bool start() const;
  void set_start(bool value);

  // @@protoc_insertion_point(class_scope:zhu.room.RoomGameStatuChangeNotify)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_start();
  void clear_has_start();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  bool start_;
  friend struct protobuf_room_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Seat

// required .zhu.room.Seat.SeatStatus statu = 1 [default = NO_PLAYER];
inline bool Seat::has_statu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Seat::set_has_statu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Seat::clear_has_statu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Seat::clear_statu() {
  statu_ = 2;
  clear_has_statu();
}
inline ::zhu::room::Seat_SeatStatus Seat::statu() const {
  // @@protoc_insertion_point(field_get:zhu.room.Seat.statu)
  return static_cast< ::zhu::room::Seat_SeatStatus >(statu_);
}
inline void Seat::set_statu(::zhu::room::Seat_SeatStatus value) {
  assert(::zhu::room::Seat_SeatStatus_IsValid(value));
  set_has_statu();
  statu_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.Seat.statu)
}

// required uint32 position = 2;
inline bool Seat::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Seat::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Seat::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Seat::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 Seat::position() const {
  // @@protoc_insertion_point(field_get:zhu.room.Seat.position)
  return position_;
}
inline void Seat::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.Seat.position)
}

// optional int32 socket = 3;
inline bool Seat::has_socket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Seat::set_has_socket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Seat::clear_has_socket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Seat::clear_socket() {
  socket_ = 0;
  clear_has_socket();
}
inline ::google::protobuf::int32 Seat::socket() const {
  // @@protoc_insertion_point(field_get:zhu.room.Seat.socket)
  return socket_;
}
inline void Seat::set_socket(::google::protobuf::int32 value) {
  set_has_socket();
  socket_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.Seat.socket)
}

// optional bytes playerAccount = 4;
inline bool Seat::has_playeraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Seat::set_has_playeraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Seat::clear_has_playeraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Seat::clear_playeraccount() {
  playeraccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_playeraccount();
}
inline const ::std::string& Seat::playeraccount() const {
  // @@protoc_insertion_point(field_get:zhu.room.Seat.playerAccount)
  return playeraccount_.GetNoArena();
}
inline void Seat::set_playeraccount(const ::std::string& value) {
  set_has_playeraccount();
  playeraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.Seat.playerAccount)
}
#if LANG_CXX11
inline void Seat::set_playeraccount(::std::string&& value) {
  set_has_playeraccount();
  playeraccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.Seat.playerAccount)
}
#endif
inline void Seat::set_playeraccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_playeraccount();
  playeraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.Seat.playerAccount)
}
inline void Seat::set_playeraccount(const void* value, size_t size) {
  set_has_playeraccount();
  playeraccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.Seat.playerAccount)
}
inline ::std::string* Seat::mutable_playeraccount() {
  set_has_playeraccount();
  // @@protoc_insertion_point(field_mutable:zhu.room.Seat.playerAccount)
  return playeraccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Seat::release_playeraccount() {
  // @@protoc_insertion_point(field_release:zhu.room.Seat.playerAccount)
  clear_has_playeraccount();
  return playeraccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Seat::set_allocated_playeraccount(::std::string* playeraccount) {
  if (playeraccount != NULL) {
    set_has_playeraccount();
  } else {
    clear_has_playeraccount();
  }
  playeraccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), playeraccount);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.Seat.playerAccount)
}

// -------------------------------------------------------------------

// Room

// required uint32 id = 1;
inline bool Room::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Room::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Room::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Room::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Room::id() const {
  // @@protoc_insertion_point(field_get:zhu.room.Room.id)
  return id_;
}
inline void Room::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.Room.id)
}

// required bytes roomName = 2;
inline bool Room::has_roomname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room::set_has_roomname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roomname();
}
inline const ::std::string& Room::roomname() const {
  // @@protoc_insertion_point(field_get:zhu.room.Room.roomName)
  return roomname_.GetNoArena();
}
inline void Room::set_roomname(const ::std::string& value) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.Room.roomName)
}
#if LANG_CXX11
inline void Room::set_roomname(::std::string&& value) {
  set_has_roomname();
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.Room.roomName)
}
#endif
inline void Room::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.Room.roomName)
}
inline void Room::set_roomname(const void* value, size_t size) {
  set_has_roomname();
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.Room.roomName)
}
inline ::std::string* Room::mutable_roomname() {
  set_has_roomname();
  // @@protoc_insertion_point(field_mutable:zhu.room.Room.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Room::release_roomname() {
  // @@protoc_insertion_point(field_release:zhu.room.Room.roomName)
  clear_has_roomname();
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Room::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    set_has_roomname();
  } else {
    clear_has_roomname();
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.Room.roomName)
}

// required uint32 userCount = 3;
inline bool Room::has_usercount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Room::set_has_usercount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Room::clear_has_usercount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Room::clear_usercount() {
  usercount_ = 0u;
  clear_has_usercount();
}
inline ::google::protobuf::uint32 Room::usercount() const {
  // @@protoc_insertion_point(field_get:zhu.room.Room.userCount)
  return usercount_;
}
inline void Room::set_usercount(::google::protobuf::uint32 value) {
  set_has_usercount();
  usercount_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.Room.userCount)
}

// optional .zhu.room.RoomStatus status = 4;
inline bool Room::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Room::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Room::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Room::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::zhu::room::RoomStatus Room::status() const {
  // @@protoc_insertion_point(field_get:zhu.room.Room.status)
  return static_cast< ::zhu::room::RoomStatus >(status_);
}
inline void Room::set_status(::zhu::room::RoomStatus value) {
  assert(::zhu::room::RoomStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.Room.status)
}

// optional .zhu.room.Seat seat1 = 5;
inline bool Room::has_seat1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room::set_has_seat1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room::clear_has_seat1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room::clear_seat1() {
  if (seat1_ != NULL) seat1_->::zhu::room::Seat::Clear();
  clear_has_seat1();
}
inline const ::zhu::room::Seat& Room::seat1() const {
  // @@protoc_insertion_point(field_get:zhu.room.Room.seat1)
  return seat1_ != NULL ? *seat1_
                         : *::zhu::room::Seat::internal_default_instance();
}
inline ::zhu::room::Seat* Room::mutable_seat1() {
  set_has_seat1();
  if (seat1_ == NULL) {
    seat1_ = new ::zhu::room::Seat;
  }
  // @@protoc_insertion_point(field_mutable:zhu.room.Room.seat1)
  return seat1_;
}
inline ::zhu::room::Seat* Room::release_seat1() {
  // @@protoc_insertion_point(field_release:zhu.room.Room.seat1)
  clear_has_seat1();
  ::zhu::room::Seat* temp = seat1_;
  seat1_ = NULL;
  return temp;
}
inline void Room::set_allocated_seat1(::zhu::room::Seat* seat1) {
  delete seat1_;
  seat1_ = seat1;
  if (seat1) {
    set_has_seat1();
  } else {
    clear_has_seat1();
  }
  // @@protoc_insertion_point(field_set_allocated:zhu.room.Room.seat1)
}

// optional .zhu.room.Seat seat2 = 6;
inline bool Room::has_seat2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Room::set_has_seat2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Room::clear_has_seat2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Room::clear_seat2() {
  if (seat2_ != NULL) seat2_->::zhu::room::Seat::Clear();
  clear_has_seat2();
}
inline const ::zhu::room::Seat& Room::seat2() const {
  // @@protoc_insertion_point(field_get:zhu.room.Room.seat2)
  return seat2_ != NULL ? *seat2_
                         : *::zhu::room::Seat::internal_default_instance();
}
inline ::zhu::room::Seat* Room::mutable_seat2() {
  set_has_seat2();
  if (seat2_ == NULL) {
    seat2_ = new ::zhu::room::Seat;
  }
  // @@protoc_insertion_point(field_mutable:zhu.room.Room.seat2)
  return seat2_;
}
inline ::zhu::room::Seat* Room::release_seat2() {
  // @@protoc_insertion_point(field_release:zhu.room.Room.seat2)
  clear_has_seat2();
  ::zhu::room::Seat* temp = seat2_;
  seat2_ = NULL;
  return temp;
}
inline void Room::set_allocated_seat2(::zhu::room::Seat* seat2) {
  delete seat2_;
  seat2_ = seat2;
  if (seat2) {
    set_has_seat2();
  } else {
    clear_has_seat2();
  }
  // @@protoc_insertion_point(field_set_allocated:zhu.room.Room.seat2)
}

// optional .zhu.room.Seat seat3 = 7;
inline bool Room::has_seat3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Room::set_has_seat3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Room::clear_has_seat3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Room::clear_seat3() {
  if (seat3_ != NULL) seat3_->::zhu::room::Seat::Clear();
  clear_has_seat3();
}
inline const ::zhu::room::Seat& Room::seat3() const {
  // @@protoc_insertion_point(field_get:zhu.room.Room.seat3)
  return seat3_ != NULL ? *seat3_
                         : *::zhu::room::Seat::internal_default_instance();
}
inline ::zhu::room::Seat* Room::mutable_seat3() {
  set_has_seat3();
  if (seat3_ == NULL) {
    seat3_ = new ::zhu::room::Seat;
  }
  // @@protoc_insertion_point(field_mutable:zhu.room.Room.seat3)
  return seat3_;
}
inline ::zhu::room::Seat* Room::release_seat3() {
  // @@protoc_insertion_point(field_release:zhu.room.Room.seat3)
  clear_has_seat3();
  ::zhu::room::Seat* temp = seat3_;
  seat3_ = NULL;
  return temp;
}
inline void Room::set_allocated_seat3(::zhu::room::Seat* seat3) {
  delete seat3_;
  seat3_ = seat3;
  if (seat3) {
    set_has_seat3();
  } else {
    clear_has_seat3();
  }
  // @@protoc_insertion_point(field_set_allocated:zhu.room.Room.seat3)
}

// -------------------------------------------------------------------

// GetRoomReq

// required bytes account = 1;
inline bool GetRoomReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoomReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoomReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoomReq::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& GetRoomReq::account() const {
  // @@protoc_insertion_point(field_get:zhu.room.GetRoomReq.account)
  return account_.GetNoArena();
}
inline void GetRoomReq::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.GetRoomReq.account)
}
#if LANG_CXX11
inline void GetRoomReq::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.GetRoomReq.account)
}
#endif
inline void GetRoomReq::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.GetRoomReq.account)
}
inline void GetRoomReq::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.GetRoomReq.account)
}
inline ::std::string* GetRoomReq::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.room.GetRoomReq.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRoomReq::release_account() {
  // @@protoc_insertion_point(field_release:zhu.room.GetRoomReq.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRoomReq::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.GetRoomReq.account)
}

// -------------------------------------------------------------------

// GetRoomResp

// required uint32 count = 1;
inline bool GetRoomResp::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoomResp::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoomResp::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoomResp::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetRoomResp::count() const {
  // @@protoc_insertion_point(field_get:zhu.room.GetRoomResp.count)
  return count_;
}
inline void GetRoomResp::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.GetRoomResp.count)
}

// repeated .zhu.room.Room room = 2;
inline int GetRoomResp::room_size() const {
  return room_.size();
}
inline void GetRoomResp::clear_room() {
  room_.Clear();
}
inline const ::zhu::room::Room& GetRoomResp::room(int index) const {
  // @@protoc_insertion_point(field_get:zhu.room.GetRoomResp.room)
  return room_.Get(index);
}
inline ::zhu::room::Room* GetRoomResp::mutable_room(int index) {
  // @@protoc_insertion_point(field_mutable:zhu.room.GetRoomResp.room)
  return room_.Mutable(index);
}
inline ::zhu::room::Room* GetRoomResp::add_room() {
  // @@protoc_insertion_point(field_add:zhu.room.GetRoomResp.room)
  return room_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zhu::room::Room >*
GetRoomResp::mutable_room() {
  // @@protoc_insertion_point(field_mutable_list:zhu.room.GetRoomResp.room)
  return &room_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zhu::room::Room >&
GetRoomResp::room() const {
  // @@protoc_insertion_point(field_list:zhu.room.GetRoomResp.room)
  return room_;
}

// -------------------------------------------------------------------

// LeaveRoomReq

// required bytes account = 1;
inline bool LeaveRoomReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveRoomReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveRoomReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveRoomReq::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& LeaveRoomReq::account() const {
  // @@protoc_insertion_point(field_get:zhu.room.LeaveRoomReq.account)
  return account_.GetNoArena();
}
inline void LeaveRoomReq::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.LeaveRoomReq.account)
}
#if LANG_CXX11
inline void LeaveRoomReq::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.LeaveRoomReq.account)
}
#endif
inline void LeaveRoomReq::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.LeaveRoomReq.account)
}
inline void LeaveRoomReq::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.LeaveRoomReq.account)
}
inline ::std::string* LeaveRoomReq::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.room.LeaveRoomReq.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LeaveRoomReq::release_account() {
  // @@protoc_insertion_point(field_release:zhu.room.LeaveRoomReq.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LeaveRoomReq::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.LeaveRoomReq.account)
}

// required uint32 roomId = 2;
inline bool LeaveRoomReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveRoomReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveRoomReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveRoomReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 LeaveRoomReq::roomid() const {
  // @@protoc_insertion_point(field_get:zhu.room.LeaveRoomReq.roomId)
  return roomid_;
}
inline void LeaveRoomReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.LeaveRoomReq.roomId)
}

// -------------------------------------------------------------------

// LeaveRoomResp

// required .zhu.room.ERROR_CODE leaveRoomResult = 1;
inline bool LeaveRoomResp::has_leaveroomresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveRoomResp::set_has_leaveroomresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveRoomResp::clear_has_leaveroomresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveRoomResp::clear_leaveroomresult() {
  leaveroomresult_ = 0;
  clear_has_leaveroomresult();
}
inline ::zhu::room::ERROR_CODE LeaveRoomResp::leaveroomresult() const {
  // @@protoc_insertion_point(field_get:zhu.room.LeaveRoomResp.leaveRoomResult)
  return static_cast< ::zhu::room::ERROR_CODE >(leaveroomresult_);
}
inline void LeaveRoomResp::set_leaveroomresult(::zhu::room::ERROR_CODE value) {
  assert(::zhu::room::ERROR_CODE_IsValid(value));
  set_has_leaveroomresult();
  leaveroomresult_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.LeaveRoomResp.leaveRoomResult)
}

// -------------------------------------------------------------------

// EnterRoomReq

// required bytes account = 1;
inline bool EnterRoomReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomReq::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& EnterRoomReq::account() const {
  // @@protoc_insertion_point(field_get:zhu.room.EnterRoomReq.account)
  return account_.GetNoArena();
}
inline void EnterRoomReq::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.EnterRoomReq.account)
}
#if LANG_CXX11
inline void EnterRoomReq::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.EnterRoomReq.account)
}
#endif
inline void EnterRoomReq::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.EnterRoomReq.account)
}
inline void EnterRoomReq::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.EnterRoomReq.account)
}
inline ::std::string* EnterRoomReq::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.room.EnterRoomReq.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnterRoomReq::release_account() {
  // @@protoc_insertion_point(field_release:zhu.room.EnterRoomReq.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnterRoomReq::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.EnterRoomReq.account)
}

// required uint32 roomId = 2;
inline bool EnterRoomReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 EnterRoomReq::roomid() const {
  // @@protoc_insertion_point(field_get:zhu.room.EnterRoomReq.roomId)
  return roomid_;
}
inline void EnterRoomReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.EnterRoomReq.roomId)
}

// -------------------------------------------------------------------

// EnterRoomResp

// required .zhu.room.ERROR_CODE enterResult = 1;
inline bool EnterRoomResp::has_enterresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoomResp::set_has_enterresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoomResp::clear_has_enterresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoomResp::clear_enterresult() {
  enterresult_ = 0;
  clear_has_enterresult();
}
inline ::zhu::room::ERROR_CODE EnterRoomResp::enterresult() const {
  // @@protoc_insertion_point(field_get:zhu.room.EnterRoomResp.enterResult)
  return static_cast< ::zhu::room::ERROR_CODE >(enterresult_);
}
inline void EnterRoomResp::set_enterresult(::zhu::room::ERROR_CODE value) {
  assert(::zhu::room::ERROR_CODE_IsValid(value));
  set_has_enterresult();
  enterresult_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.EnterRoomResp.enterResult)
}

// optional .zhu.room.Room roomInfo = 2;
inline bool EnterRoomResp::has_roominfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoomResp::set_has_roominfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoomResp::clear_has_roominfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoomResp::clear_roominfo() {
  if (roominfo_ != NULL) roominfo_->::zhu::room::Room::Clear();
  clear_has_roominfo();
}
inline const ::zhu::room::Room& EnterRoomResp::roominfo() const {
  // @@protoc_insertion_point(field_get:zhu.room.EnterRoomResp.roomInfo)
  return roominfo_ != NULL ? *roominfo_
                         : *::zhu::room::Room::internal_default_instance();
}
inline ::zhu::room::Room* EnterRoomResp::mutable_roominfo() {
  set_has_roominfo();
  if (roominfo_ == NULL) {
    roominfo_ = new ::zhu::room::Room;
  }
  // @@protoc_insertion_point(field_mutable:zhu.room.EnterRoomResp.roomInfo)
  return roominfo_;
}
inline ::zhu::room::Room* EnterRoomResp::release_roominfo() {
  // @@protoc_insertion_point(field_release:zhu.room.EnterRoomResp.roomInfo)
  clear_has_roominfo();
  ::zhu::room::Room* temp = roominfo_;
  roominfo_ = NULL;
  return temp;
}
inline void EnterRoomResp::set_allocated_roominfo(::zhu::room::Room* roominfo) {
  delete roominfo_;
  roominfo_ = roominfo;
  if (roominfo) {
    set_has_roominfo();
  } else {
    clear_has_roominfo();
  }
  // @@protoc_insertion_point(field_set_allocated:zhu.room.EnterRoomResp.roomInfo)
}

// optional bytes desc = 3;
inline bool EnterRoomResp::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoomResp::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoomResp::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoomResp::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& EnterRoomResp::desc() const {
  // @@protoc_insertion_point(field_get:zhu.room.EnterRoomResp.desc)
  return desc_.GetNoArena();
}
inline void EnterRoomResp::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.EnterRoomResp.desc)
}
#if LANG_CXX11
inline void EnterRoomResp::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.EnterRoomResp.desc)
}
#endif
inline void EnterRoomResp::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.EnterRoomResp.desc)
}
inline void EnterRoomResp::set_desc(const void* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.EnterRoomResp.desc)
}
inline ::std::string* EnterRoomResp::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:zhu.room.EnterRoomResp.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnterRoomResp::release_desc() {
  // @@protoc_insertion_point(field_release:zhu.room.EnterRoomResp.desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnterRoomResp::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.EnterRoomResp.desc)
}

// optional uint32 position = 4;
inline bool EnterRoomResp::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterRoomResp::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterRoomResp::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterRoomResp::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 EnterRoomResp::position() const {
  // @@protoc_insertion_point(field_get:zhu.room.EnterRoomResp.position)
  return position_;
}
inline void EnterRoomResp::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.EnterRoomResp.position)
}

// -------------------------------------------------------------------

// CreateRoomReq

// required bytes account = 1;
inline bool CreateRoomReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomReq::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& CreateRoomReq::account() const {
  // @@protoc_insertion_point(field_get:zhu.room.CreateRoomReq.account)
  return account_.GetNoArena();
}
inline void CreateRoomReq::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.CreateRoomReq.account)
}
#if LANG_CXX11
inline void CreateRoomReq::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.CreateRoomReq.account)
}
#endif
inline void CreateRoomReq::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.CreateRoomReq.account)
}
inline void CreateRoomReq::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.CreateRoomReq.account)
}
inline ::std::string* CreateRoomReq::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.room.CreateRoomReq.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomReq::release_account() {
  // @@protoc_insertion_point(field_release:zhu.room.CreateRoomReq.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomReq::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.CreateRoomReq.account)
}

// -------------------------------------------------------------------

// CreateRoomResp

// required .zhu.room.ERROR_CODE createResult = 1;
inline bool CreateRoomResp::has_createresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoomResp::set_has_createresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoomResp::clear_has_createresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoomResp::clear_createresult() {
  createresult_ = 0;
  clear_has_createresult();
}
inline ::zhu::room::ERROR_CODE CreateRoomResp::createresult() const {
  // @@protoc_insertion_point(field_get:zhu.room.CreateRoomResp.createResult)
  return static_cast< ::zhu::room::ERROR_CODE >(createresult_);
}
inline void CreateRoomResp::set_createresult(::zhu::room::ERROR_CODE value) {
  assert(::zhu::room::ERROR_CODE_IsValid(value));
  set_has_createresult();
  createresult_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.CreateRoomResp.createResult)
}

// optional bytes desc = 2;
inline bool CreateRoomResp::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoomResp::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoomResp::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoomResp::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& CreateRoomResp::desc() const {
  // @@protoc_insertion_point(field_get:zhu.room.CreateRoomResp.desc)
  return desc_.GetNoArena();
}
inline void CreateRoomResp::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.CreateRoomResp.desc)
}
#if LANG_CXX11
inline void CreateRoomResp::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.CreateRoomResp.desc)
}
#endif
inline void CreateRoomResp::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.CreateRoomResp.desc)
}
inline void CreateRoomResp::set_desc(const void* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.CreateRoomResp.desc)
}
inline ::std::string* CreateRoomResp::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:zhu.room.CreateRoomResp.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoomResp::release_desc() {
  // @@protoc_insertion_point(field_release:zhu.room.CreateRoomResp.desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoomResp::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.CreateRoomResp.desc)
}

// optional .zhu.room.Room createRoom = 3;
inline bool CreateRoomResp::has_createroom() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoomResp::set_has_createroom() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoomResp::clear_has_createroom() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoomResp::clear_createroom() {
  if (createroom_ != NULL) createroom_->::zhu::room::Room::Clear();
  clear_has_createroom();
}
inline const ::zhu::room::Room& CreateRoomResp::createroom() const {
  // @@protoc_insertion_point(field_get:zhu.room.CreateRoomResp.createRoom)
  return createroom_ != NULL ? *createroom_
                         : *::zhu::room::Room::internal_default_instance();
}
inline ::zhu::room::Room* CreateRoomResp::mutable_createroom() {
  set_has_createroom();
  if (createroom_ == NULL) {
    createroom_ = new ::zhu::room::Room;
  }
  // @@protoc_insertion_point(field_mutable:zhu.room.CreateRoomResp.createRoom)
  return createroom_;
}
inline ::zhu::room::Room* CreateRoomResp::release_createroom() {
  // @@protoc_insertion_point(field_release:zhu.room.CreateRoomResp.createRoom)
  clear_has_createroom();
  ::zhu::room::Room* temp = createroom_;
  createroom_ = NULL;
  return temp;
}
inline void CreateRoomResp::set_allocated_createroom(::zhu::room::Room* createroom) {
  delete createroom_;
  createroom_ = createroom;
  if (createroom) {
    set_has_createroom();
  } else {
    clear_has_createroom();
  }
  // @@protoc_insertion_point(field_set_allocated:zhu.room.CreateRoomResp.createRoom)
}

// -------------------------------------------------------------------

// ReadyReq

// required bytes account = 1;
inline bool ReadyReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadyReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadyReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadyReq::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& ReadyReq::account() const {
  // @@protoc_insertion_point(field_get:zhu.room.ReadyReq.account)
  return account_.GetNoArena();
}
inline void ReadyReq::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.ReadyReq.account)
}
#if LANG_CXX11
inline void ReadyReq::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.ReadyReq.account)
}
#endif
inline void ReadyReq::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.ReadyReq.account)
}
inline void ReadyReq::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.ReadyReq.account)
}
inline ::std::string* ReadyReq::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.room.ReadyReq.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadyReq::release_account() {
  // @@protoc_insertion_point(field_release:zhu.room.ReadyReq.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadyReq::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.ReadyReq.account)
}

// required uint32 roomid = 2;
inline bool ReadyReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadyReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadyReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadyReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 ReadyReq::roomid() const {
  // @@protoc_insertion_point(field_get:zhu.room.ReadyReq.roomid)
  return roomid_;
}
inline void ReadyReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.ReadyReq.roomid)
}

// required bool ready = 3;
inline bool ReadyReq::has_ready() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReadyReq::set_has_ready() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReadyReq::clear_has_ready() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReadyReq::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool ReadyReq::ready() const {
  // @@protoc_insertion_point(field_get:zhu.room.ReadyReq.ready)
  return ready_;
}
inline void ReadyReq::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.ReadyReq.ready)
}

// -------------------------------------------------------------------

// ReadyResp

// required .zhu.room.ERROR_CODE readyResult = 1;
inline bool ReadyResp::has_readyresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReadyResp::set_has_readyresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReadyResp::clear_has_readyresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReadyResp::clear_readyresult() {
  readyresult_ = 0;
  clear_has_readyresult();
}
inline ::zhu::room::ERROR_CODE ReadyResp::readyresult() const {
  // @@protoc_insertion_point(field_get:zhu.room.ReadyResp.readyResult)
  return static_cast< ::zhu::room::ERROR_CODE >(readyresult_);
}
inline void ReadyResp::set_readyresult(::zhu::room::ERROR_CODE value) {
  assert(::zhu::room::ERROR_CODE_IsValid(value));
  set_has_readyresult();
  readyresult_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.ReadyResp.readyResult)
}

// optional bytes account = 2;
inline bool ReadyResp::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadyResp::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadyResp::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadyResp::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& ReadyResp::account() const {
  // @@protoc_insertion_point(field_get:zhu.room.ReadyResp.account)
  return account_.GetNoArena();
}
inline void ReadyResp::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.ReadyResp.account)
}
#if LANG_CXX11
inline void ReadyResp::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.ReadyResp.account)
}
#endif
inline void ReadyResp::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.ReadyResp.account)
}
inline void ReadyResp::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.ReadyResp.account)
}
inline ::std::string* ReadyResp::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.room.ReadyResp.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadyResp::release_account() {
  // @@protoc_insertion_point(field_release:zhu.room.ReadyResp.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadyResp::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.ReadyResp.account)
}

// optional uint32 position = 3;
inline bool ReadyResp::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReadyResp::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReadyResp::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReadyResp::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 ReadyResp::position() const {
  // @@protoc_insertion_point(field_get:zhu.room.ReadyResp.position)
  return position_;
}
inline void ReadyResp::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.ReadyResp.position)
}

// optional bool ready = 4;
inline bool ReadyResp::has_ready() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReadyResp::set_has_ready() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReadyResp::clear_has_ready() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReadyResp::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool ReadyResp::ready() const {
  // @@protoc_insertion_point(field_get:zhu.room.ReadyResp.ready)
  return ready_;
}
inline void ReadyResp::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.ReadyResp.ready)
}

// optional bytes desc = 5;
inline bool ReadyResp::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadyResp::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadyResp::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadyResp::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& ReadyResp::desc() const {
  // @@protoc_insertion_point(field_get:zhu.room.ReadyResp.desc)
  return desc_.GetNoArena();
}
inline void ReadyResp::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.ReadyResp.desc)
}
#if LANG_CXX11
inline void ReadyResp::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.ReadyResp.desc)
}
#endif
inline void ReadyResp::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.ReadyResp.desc)
}
inline void ReadyResp::set_desc(const void* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.ReadyResp.desc)
}
inline ::std::string* ReadyResp::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:zhu.room.ReadyResp.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadyResp::release_desc() {
  // @@protoc_insertion_point(field_release:zhu.room.ReadyResp.desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadyResp::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.ReadyResp.desc)
}

// -------------------------------------------------------------------

// GameOverMsg

// required uint32 roomid = 1;
inline bool GameOverMsg::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameOverMsg::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameOverMsg::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameOverMsg::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 GameOverMsg::roomid() const {
  // @@protoc_insertion_point(field_get:zhu.room.GameOverMsg.roomid)
  return roomid_;
}
inline void GameOverMsg::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.GameOverMsg.roomid)
}

// optional bytes winFirstAccount = 2;
inline bool GameOverMsg::has_winfirstaccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameOverMsg::set_has_winfirstaccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameOverMsg::clear_has_winfirstaccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameOverMsg::clear_winfirstaccount() {
  winfirstaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_winfirstaccount();
}
inline const ::std::string& GameOverMsg::winfirstaccount() const {
  // @@protoc_insertion_point(field_get:zhu.room.GameOverMsg.winFirstAccount)
  return winfirstaccount_.GetNoArena();
}
inline void GameOverMsg::set_winfirstaccount(const ::std::string& value) {
  set_has_winfirstaccount();
  winfirstaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.GameOverMsg.winFirstAccount)
}
#if LANG_CXX11
inline void GameOverMsg::set_winfirstaccount(::std::string&& value) {
  set_has_winfirstaccount();
  winfirstaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.GameOverMsg.winFirstAccount)
}
#endif
inline void GameOverMsg::set_winfirstaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_winfirstaccount();
  winfirstaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.GameOverMsg.winFirstAccount)
}
inline void GameOverMsg::set_winfirstaccount(const void* value, size_t size) {
  set_has_winfirstaccount();
  winfirstaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.GameOverMsg.winFirstAccount)
}
inline ::std::string* GameOverMsg::mutable_winfirstaccount() {
  set_has_winfirstaccount();
  // @@protoc_insertion_point(field_mutable:zhu.room.GameOverMsg.winFirstAccount)
  return winfirstaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameOverMsg::release_winfirstaccount() {
  // @@protoc_insertion_point(field_release:zhu.room.GameOverMsg.winFirstAccount)
  clear_has_winfirstaccount();
  return winfirstaccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameOverMsg::set_allocated_winfirstaccount(::std::string* winfirstaccount) {
  if (winfirstaccount != NULL) {
    set_has_winfirstaccount();
  } else {
    clear_has_winfirstaccount();
  }
  winfirstaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), winfirstaccount);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.GameOverMsg.winFirstAccount)
}

// optional bytes winSecondAccount = 3;
inline bool GameOverMsg::has_winsecondaccount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameOverMsg::set_has_winsecondaccount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameOverMsg::clear_has_winsecondaccount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameOverMsg::clear_winsecondaccount() {
  winsecondaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_winsecondaccount();
}
inline const ::std::string& GameOverMsg::winsecondaccount() const {
  // @@protoc_insertion_point(field_get:zhu.room.GameOverMsg.winSecondAccount)
  return winsecondaccount_.GetNoArena();
}
inline void GameOverMsg::set_winsecondaccount(const ::std::string& value) {
  set_has_winsecondaccount();
  winsecondaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.GameOverMsg.winSecondAccount)
}
#if LANG_CXX11
inline void GameOverMsg::set_winsecondaccount(::std::string&& value) {
  set_has_winsecondaccount();
  winsecondaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.GameOverMsg.winSecondAccount)
}
#endif
inline void GameOverMsg::set_winsecondaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_winsecondaccount();
  winsecondaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.GameOverMsg.winSecondAccount)
}
inline void GameOverMsg::set_winsecondaccount(const void* value, size_t size) {
  set_has_winsecondaccount();
  winsecondaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.GameOverMsg.winSecondAccount)
}
inline ::std::string* GameOverMsg::mutable_winsecondaccount() {
  set_has_winsecondaccount();
  // @@protoc_insertion_point(field_mutable:zhu.room.GameOverMsg.winSecondAccount)
  return winsecondaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameOverMsg::release_winsecondaccount() {
  // @@protoc_insertion_point(field_release:zhu.room.GameOverMsg.winSecondAccount)
  clear_has_winsecondaccount();
  return winsecondaccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameOverMsg::set_allocated_winsecondaccount(::std::string* winsecondaccount) {
  if (winsecondaccount != NULL) {
    set_has_winsecondaccount();
  } else {
    clear_has_winsecondaccount();
  }
  winsecondaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), winsecondaccount);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.GameOverMsg.winSecondAccount)
}

// optional bytes loseFirstAccount = 4;
inline bool GameOverMsg::has_losefirstaccount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameOverMsg::set_has_losefirstaccount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameOverMsg::clear_has_losefirstaccount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameOverMsg::clear_losefirstaccount() {
  losefirstaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_losefirstaccount();
}
inline const ::std::string& GameOverMsg::losefirstaccount() const {
  // @@protoc_insertion_point(field_get:zhu.room.GameOverMsg.loseFirstAccount)
  return losefirstaccount_.GetNoArena();
}
inline void GameOverMsg::set_losefirstaccount(const ::std::string& value) {
  set_has_losefirstaccount();
  losefirstaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.GameOverMsg.loseFirstAccount)
}
#if LANG_CXX11
inline void GameOverMsg::set_losefirstaccount(::std::string&& value) {
  set_has_losefirstaccount();
  losefirstaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.GameOverMsg.loseFirstAccount)
}
#endif
inline void GameOverMsg::set_losefirstaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_losefirstaccount();
  losefirstaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.GameOverMsg.loseFirstAccount)
}
inline void GameOverMsg::set_losefirstaccount(const void* value, size_t size) {
  set_has_losefirstaccount();
  losefirstaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.GameOverMsg.loseFirstAccount)
}
inline ::std::string* GameOverMsg::mutable_losefirstaccount() {
  set_has_losefirstaccount();
  // @@protoc_insertion_point(field_mutable:zhu.room.GameOverMsg.loseFirstAccount)
  return losefirstaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameOverMsg::release_losefirstaccount() {
  // @@protoc_insertion_point(field_release:zhu.room.GameOverMsg.loseFirstAccount)
  clear_has_losefirstaccount();
  return losefirstaccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameOverMsg::set_allocated_losefirstaccount(::std::string* losefirstaccount) {
  if (losefirstaccount != NULL) {
    set_has_losefirstaccount();
  } else {
    clear_has_losefirstaccount();
  }
  losefirstaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), losefirstaccount);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.GameOverMsg.loseFirstAccount)
}

// optional bytes loseSecondAccount = 5;
inline bool GameOverMsg::has_losesecondaccount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameOverMsg::set_has_losesecondaccount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameOverMsg::clear_has_losesecondaccount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameOverMsg::clear_losesecondaccount() {
  losesecondaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_losesecondaccount();
}
inline const ::std::string& GameOverMsg::losesecondaccount() const {
  // @@protoc_insertion_point(field_get:zhu.room.GameOverMsg.loseSecondAccount)
  return losesecondaccount_.GetNoArena();
}
inline void GameOverMsg::set_losesecondaccount(const ::std::string& value) {
  set_has_losesecondaccount();
  losesecondaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.room.GameOverMsg.loseSecondAccount)
}
#if LANG_CXX11
inline void GameOverMsg::set_losesecondaccount(::std::string&& value) {
  set_has_losesecondaccount();
  losesecondaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.room.GameOverMsg.loseSecondAccount)
}
#endif
inline void GameOverMsg::set_losesecondaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_losesecondaccount();
  losesecondaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.room.GameOverMsg.loseSecondAccount)
}
inline void GameOverMsg::set_losesecondaccount(const void* value, size_t size) {
  set_has_losesecondaccount();
  losesecondaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.room.GameOverMsg.loseSecondAccount)
}
inline ::std::string* GameOverMsg::mutable_losesecondaccount() {
  set_has_losesecondaccount();
  // @@protoc_insertion_point(field_mutable:zhu.room.GameOverMsg.loseSecondAccount)
  return losesecondaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameOverMsg::release_losesecondaccount() {
  // @@protoc_insertion_point(field_release:zhu.room.GameOverMsg.loseSecondAccount)
  clear_has_losesecondaccount();
  return losesecondaccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameOverMsg::set_allocated_losesecondaccount(::std::string* losesecondaccount) {
  if (losesecondaccount != NULL) {
    set_has_losesecondaccount();
  } else {
    clear_has_losesecondaccount();
  }
  losesecondaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), losesecondaccount);
  // @@protoc_insertion_point(field_set_allocated:zhu.room.GameOverMsg.loseSecondAccount)
}

// -------------------------------------------------------------------

// RoomUserCountChangeNotify

// required uint32 id = 1;
inline bool RoomUserCountChangeNotify::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomUserCountChangeNotify::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomUserCountChangeNotify::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomUserCountChangeNotify::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 RoomUserCountChangeNotify::id() const {
  // @@protoc_insertion_point(field_get:zhu.room.RoomUserCountChangeNotify.id)
  return id_;
}
inline void RoomUserCountChangeNotify::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.RoomUserCountChangeNotify.id)
}

// required uint32 count = 2;
inline bool RoomUserCountChangeNotify::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomUserCountChangeNotify::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomUserCountChangeNotify::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomUserCountChangeNotify::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RoomUserCountChangeNotify::count() const {
  // @@protoc_insertion_point(field_get:zhu.room.RoomUserCountChangeNotify.count)
  return count_;
}
inline void RoomUserCountChangeNotify::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.RoomUserCountChangeNotify.count)
}

// -------------------------------------------------------------------

// RoomGameStatuChangeNotify

// required uint32 id = 1;
inline bool RoomGameStatuChangeNotify::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomGameStatuChangeNotify::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomGameStatuChangeNotify::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomGameStatuChangeNotify::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 RoomGameStatuChangeNotify::id() const {
  // @@protoc_insertion_point(field_get:zhu.room.RoomGameStatuChangeNotify.id)
  return id_;
}
inline void RoomGameStatuChangeNotify::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.RoomGameStatuChangeNotify.id)
}

// required bool start = 2;
inline bool RoomGameStatuChangeNotify::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomGameStatuChangeNotify::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomGameStatuChangeNotify::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomGameStatuChangeNotify::clear_start() {
  start_ = false;
  clear_has_start();
}
inline bool RoomGameStatuChangeNotify::start() const {
  // @@protoc_insertion_point(field_get:zhu.room.RoomGameStatuChangeNotify.start)
  return start_;
}
inline void RoomGameStatuChangeNotify::set_start(bool value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:zhu.room.RoomGameStatuChangeNotify.start)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace room
}  // namespace zhu

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zhu::room::Seat_SeatStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zhu::room::Seat_SeatStatus>() {
  return ::zhu::room::Seat_SeatStatus_descriptor();
}
template <> struct is_proto_enum< ::zhu::room::RoomStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zhu::room::RoomStatus>() {
  return ::zhu::room::RoomStatus_descriptor();
}
template <> struct is_proto_enum< ::zhu::room::ERROR_CODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zhu::room::ERROR_CODE>() {
  return ::zhu::room::ERROR_CODE_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_room_2eproto__INCLUDED
