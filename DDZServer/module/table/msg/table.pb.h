// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: table.proto

#ifndef PROTOBUF_table_2eproto__INCLUDED
#define PROTOBUF_table_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace zhu {
namespace table {
class DispatchPoker;
class DispatchPokerDefaultTypeInternal;
extern DispatchPokerDefaultTypeInternal _DispatchPoker_default_instance_;
class PlayReq;
class PlayReqDefaultTypeInternal;
extern PlayReqDefaultTypeInternal _PlayReq_default_instance_;
class PlayResp;
class PlayRespDefaultTypeInternal;
extern PlayRespDefaultTypeInternal _PlayResp_default_instance_;
class PlayerOut;
class PlayerOutDefaultTypeInternal;
extern PlayerOutDefaultTypeInternal _PlayerOut_default_instance_;
class Poker;
class PokerDefaultTypeInternal;
extern PokerDefaultTypeInternal _Poker_default_instance_;
class RequestLandlordReq;
class RequestLandlordReqDefaultTypeInternal;
extern RequestLandlordReqDefaultTypeInternal _RequestLandlordReq_default_instance_;
class RequestLandlordResp;
class RequestLandlordRespDefaultTypeInternal;
extern RequestLandlordRespDefaultTypeInternal _RequestLandlordResp_default_instance_;
}  // namespace table
}  // namespace zhu

namespace zhu {
namespace table {

namespace protobuf_table_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_table_2eproto

enum POKER_SUIT {
  SPADE = 0,
  HEART = 1,
  DIAMOND = 2,
  CLUB = 3,
  SMALL_JACKER = 4,
  BIG_JACKER = 5
};
bool POKER_SUIT_IsValid(int value);
const POKER_SUIT POKER_SUIT_MIN = SPADE;
const POKER_SUIT POKER_SUIT_MAX = BIG_JACKER;
const int POKER_SUIT_ARRAYSIZE = POKER_SUIT_MAX + 1;

const ::google::protobuf::EnumDescriptor* POKER_SUIT_descriptor();
inline const ::std::string& POKER_SUIT_Name(POKER_SUIT value) {
  return ::google::protobuf::internal::NameOfEnum(
    POKER_SUIT_descriptor(), value);
}
inline bool POKER_SUIT_Parse(
    const ::std::string& name, POKER_SUIT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<POKER_SUIT>(
    POKER_SUIT_descriptor(), name, value);
}
enum PLAY_TYPE {
  DOUBLE_JOCKER = 0,
  BOMB = 1,
  SINGLE = 2,
  DOUBLE_SAME = 3,
  THREE_SAME = 4,
  THREE_SAME_WITH_ONE = 5,
  THREE_SAME_WITH_TWO = 6,
  SINGLE_STRAIGHT = 7,
  DOUBLE_STRAIGHT = 8,
  BOMB_WIHT_SINGLE = 9,
  BOMB_WIHT_DOUBLE = 10,
  NO_PLAYER = 11,
  DOUBLE_THREE_SAME = 12,
  DOUBLE_THREE_SAME_WITH_SINGLE = 13,
  DOUBLE_THREE_SAME_WITH_DOUBLE = 14,
  THREE_THREE_SAME = 15,
  THREE_THREE_SAME_WITH_SINGLE = 16,
  THREE_THREE_SAME_WITH_DOUBLE = 17,
  FOUR_THREE_SAME = 18,
  FOUR_THREE_SAME_WITH_SINGLE = 19,
  FIVE_THREE_SAME = 20
};
bool PLAY_TYPE_IsValid(int value);
const PLAY_TYPE PLAY_TYPE_MIN = DOUBLE_JOCKER;
const PLAY_TYPE PLAY_TYPE_MAX = FIVE_THREE_SAME;
const int PLAY_TYPE_ARRAYSIZE = PLAY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PLAY_TYPE_descriptor();
inline const ::std::string& PLAY_TYPE_Name(PLAY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PLAY_TYPE_descriptor(), value);
}
inline bool PLAY_TYPE_Parse(
    const ::std::string& name, PLAY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PLAY_TYPE>(
    PLAY_TYPE_descriptor(), name, value);
}
enum ERROR_CODE {
  SUCCESS = 0,
  NO_TURN_TO_REQUEST = 1,
  PLAY_TYPE_ERROR = 2,
  COMPARE_LOSE = 3,
  NO_PLAY = 4,
  CAN_NOT_CALL_LANDLORD = 5,
  NO_ONE_CALL_LANDLORD = 6,
  NOT_SELECTED_LANDLORD = 7,
  SELECTED_LANDLORD = 8,
  LANDLORD_WIN = 9,
  PEASANT_WIN = 10,
  CAN_NOT_NO_PLAY = 11,
  PLAYER_OUT_GAME = 12,
  SERVER_ERROR = 13
};
bool ERROR_CODE_IsValid(int value);
const ERROR_CODE ERROR_CODE_MIN = SUCCESS;
const ERROR_CODE ERROR_CODE_MAX = SERVER_ERROR;
const int ERROR_CODE_ARRAYSIZE = ERROR_CODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERROR_CODE_descriptor();
inline const ::std::string& ERROR_CODE_Name(ERROR_CODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERROR_CODE_descriptor(), value);
}
inline bool ERROR_CODE_Parse(
    const ::std::string& name, ERROR_CODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERROR_CODE>(
    ERROR_CODE_descriptor(), name, value);
}
enum RequestLandlordType {
  RUSH = 0,
  CALL = 1
};
bool RequestLandlordType_IsValid(int value);
const RequestLandlordType RequestLandlordType_MIN = RUSH;
const RequestLandlordType RequestLandlordType_MAX = CALL;
const int RequestLandlordType_ARRAYSIZE = RequestLandlordType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestLandlordType_descriptor();
inline const ::std::string& RequestLandlordType_Name(RequestLandlordType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestLandlordType_descriptor(), value);
}
inline bool RequestLandlordType_Parse(
    const ::std::string& name, RequestLandlordType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestLandlordType>(
    RequestLandlordType_descriptor(), name, value);
}
enum DispatchPokerType {
  DEAL_POKER = 0,
  LANDLORD_POKER = 1,
  CURRENT_POKER = 2,
  PLAYER_POKER = 3
};
bool DispatchPokerType_IsValid(int value);
const DispatchPokerType DispatchPokerType_MIN = DEAL_POKER;
const DispatchPokerType DispatchPokerType_MAX = PLAYER_POKER;
const int DispatchPokerType_ARRAYSIZE = DispatchPokerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DispatchPokerType_descriptor();
inline const ::std::string& DispatchPokerType_Name(DispatchPokerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DispatchPokerType_descriptor(), value);
}
inline bool DispatchPokerType_Parse(
    const ::std::string& name, DispatchPokerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DispatchPokerType>(
    DispatchPokerType_descriptor(), name, value);
}
// ===================================================================

class Poker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.table.Poker) */ {
 public:
  Poker();
  virtual ~Poker();

  Poker(const Poker& from);

  inline Poker& operator=(const Poker& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Poker& default_instance();

  static inline const Poker* internal_default_instance() {
    return reinterpret_cast<const Poker*>(
               &_Poker_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Poker* other);

  // implements Message ----------------------------------------------

  inline Poker* New() const PROTOBUF_FINAL { return New(NULL); }

  Poker* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Poker& from);
  void MergeFrom(const Poker& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Poker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 number = 1;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 1;
  ::google::protobuf::uint32 number() const;
  void set_number(::google::protobuf::uint32 value);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // required .zhu.table.POKER_SUIT suit = 3;
  bool has_suit() const;
  void clear_suit();
  static const int kSuitFieldNumber = 3;
  ::zhu::table::POKER_SUIT suit() const;
  void set_suit(::zhu::table::POKER_SUIT value);

  // @@protoc_insertion_point(class_scope:zhu.table.Poker)
 private:
  void set_has_number();
  void clear_has_number();
  void set_has_value();
  void clear_has_value();
  void set_has_suit();
  void clear_has_suit();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 number_;
  ::google::protobuf::int32 value_;
  int suit_;
  friend struct protobuf_table_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.table.PlayReq) */ {
 public:
  PlayReq();
  virtual ~PlayReq();

  PlayReq(const PlayReq& from);

  inline PlayReq& operator=(const PlayReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayReq& default_instance();

  static inline const PlayReq* internal_default_instance() {
    return reinterpret_cast<const PlayReq*>(
               &_PlayReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PlayReq* other);

  // implements Message ----------------------------------------------

  inline PlayReq* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayReq& from);
  void MergeFrom(const PlayReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zhu.table.Poker pokers = 4;
  int pokers_size() const;
  void clear_pokers();
  static const int kPokersFieldNumber = 4;
  const ::zhu::table::Poker& pokers(int index) const;
  ::zhu::table::Poker* mutable_pokers(int index);
  ::zhu::table::Poker* add_pokers();
  ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker >*
      mutable_pokers();
  const ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker >&
      pokers() const;

  // required bytes account = 2;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // required uint32 roomId = 1;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // required .zhu.table.PLAY_TYPE type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::zhu::table::PLAY_TYPE type() const;
  void set_type(::zhu::table::PLAY_TYPE value);

  // @@protoc_insertion_point(class_scope:zhu.table.PlayReq)
 private:
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_account();
  void clear_has_account();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker > pokers_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::uint32 roomid_;
  int type_;
  friend struct protobuf_table_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.table.PlayResp) */ {
 public:
  PlayResp();
  virtual ~PlayResp();

  PlayResp(const PlayResp& from);

  inline PlayResp& operator=(const PlayResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayResp& default_instance();

  static inline const PlayResp* internal_default_instance() {
    return reinterpret_cast<const PlayResp*>(
               &_PlayResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PlayResp* other);

  // implements Message ----------------------------------------------

  inline PlayResp* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayResp& from);
  void MergeFrom(const PlayResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // optional bytes account = 3;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 3;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // optional bytes next = 4;
  bool has_next() const;
  void clear_next();
  static const int kNextFieldNumber = 4;
  const ::std::string& next() const;
  void set_next(const ::std::string& value);
  #if LANG_CXX11
  void set_next(::std::string&& value);
  #endif
  void set_next(const char* value);
  void set_next(const void* value, size_t size);
  ::std::string* mutable_next();
  ::std::string* release_next();
  void set_allocated_next(::std::string* next);

  // required .zhu.table.ERROR_CODE playResult = 1;
  bool has_playresult() const;
  void clear_playresult();
  static const int kPlayResultFieldNumber = 1;
  ::zhu::table::ERROR_CODE playresult() const;
  void set_playresult(::zhu::table::ERROR_CODE value);

  // optional uint32 nextPosition = 5;
  bool has_nextposition() const;
  void clear_nextposition();
  static const int kNextPositionFieldNumber = 5;
  ::google::protobuf::uint32 nextposition() const;
  void set_nextposition(::google::protobuf::uint32 value);

  // optional uint32 currentPosition = 6;
  bool has_currentposition() const;
  void clear_currentposition();
  static const int kCurrentPositionFieldNumber = 6;
  ::google::protobuf::uint32 currentposition() const;
  void set_currentposition(::google::protobuf::uint32 value);

  // optional uint32 number = 7;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 7;
  ::google::protobuf::uint32 number() const;
  void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhu.table.PlayResp)
 private:
  void set_has_playresult();
  void clear_has_playresult();
  void set_has_desc();
  void clear_has_desc();
  void set_has_account();
  void clear_has_account();
  void set_has_next();
  void clear_has_next();
  void set_has_nextposition();
  void clear_has_nextposition();
  void set_has_currentposition();
  void clear_has_currentposition();
  void set_has_number();
  void clear_has_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr next_;
  int playresult_;
  ::google::protobuf::uint32 nextposition_;
  ::google::protobuf::uint32 currentposition_;
  ::google::protobuf::uint32 number_;
  friend struct protobuf_table_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestLandlordReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.table.RequestLandlordReq) */ {
 public:
  RequestLandlordReq();
  virtual ~RequestLandlordReq();

  RequestLandlordReq(const RequestLandlordReq& from);

  inline RequestLandlordReq& operator=(const RequestLandlordReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLandlordReq& default_instance();

  static inline const RequestLandlordReq* internal_default_instance() {
    return reinterpret_cast<const RequestLandlordReq*>(
               &_RequestLandlordReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RequestLandlordReq* other);

  // implements Message ----------------------------------------------

  inline RequestLandlordReq* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestLandlordReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestLandlordReq& from);
  void MergeFrom(const RequestLandlordReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestLandlordReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes account = 2;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // required uint32 roomId = 1;
  bool has_roomid() const;
  void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  ::google::protobuf::uint32 roomid() const;
  void set_roomid(::google::protobuf::uint32 value);

  // required bool call = 3;
  bool has_call() const;
  void clear_call();
  static const int kCallFieldNumber = 3;
  bool call() const;
  void set_call(bool value);

  // optional .zhu.table.RequestLandlordType type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::zhu::table::RequestLandlordType type() const;
  void set_type(::zhu::table::RequestLandlordType value);

  // @@protoc_insertion_point(class_scope:zhu.table.RequestLandlordReq)
 private:
  void set_has_roomid();
  void clear_has_roomid();
  void set_has_account();
  void clear_has_account();
  void set_has_call();
  void clear_has_call();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::uint32 roomid_;
  bool call_;
  int type_;
  friend struct protobuf_table_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestLandlordResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.table.RequestLandlordResp) */ {
 public:
  RequestLandlordResp();
  virtual ~RequestLandlordResp();

  RequestLandlordResp(const RequestLandlordResp& from);

  inline RequestLandlordResp& operator=(const RequestLandlordResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLandlordResp& default_instance();

  static inline const RequestLandlordResp* internal_default_instance() {
    return reinterpret_cast<const RequestLandlordResp*>(
               &_RequestLandlordResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RequestLandlordResp* other);

  // implements Message ----------------------------------------------

  inline RequestLandlordResp* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestLandlordResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestLandlordResp& from);
  void MergeFrom(const RequestLandlordResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestLandlordResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // optional bytes account = 3;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 3;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // optional bytes next = 8;
  bool has_next() const;
  void clear_next();
  static const int kNextFieldNumber = 8;
  const ::std::string& next() const;
  void set_next(const ::std::string& value);
  #if LANG_CXX11
  void set_next(::std::string&& value);
  #endif
  void set_next(const char* value);
  void set_next(const void* value, size_t size);
  ::std::string* mutable_next();
  ::std::string* release_next();
  void set_allocated_next(::std::string* next);

  // required .zhu.table.ERROR_CODE callLandlordResult = 1;
  bool has_calllandlordresult() const;
  void clear_calllandlordresult();
  static const int kCallLandlordResultFieldNumber = 1;
  ::zhu::table::ERROR_CODE calllandlordresult() const;
  void set_calllandlordresult(::zhu::table::ERROR_CODE value);

  // optional uint32 currentPosition = 4;
  bool has_currentposition() const;
  void clear_currentposition();
  static const int kCurrentPositionFieldNumber = 4;
  ::google::protobuf::uint32 currentposition() const;
  void set_currentposition(::google::protobuf::uint32 value);

  // optional bool call = 5;
  bool has_call() const;
  void clear_call();
  static const int kCallFieldNumber = 5;
  bool call() const;
  void set_call(bool value);

  // optional .zhu.table.RequestLandlordType type = 6;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  ::zhu::table::RequestLandlordType type() const;
  void set_type(::zhu::table::RequestLandlordType value);

  // optional .zhu.table.RequestLandlordType nextType = 7;
  bool has_nexttype() const;
  void clear_nexttype();
  static const int kNextTypeFieldNumber = 7;
  ::zhu::table::RequestLandlordType nexttype() const;
  void set_nexttype(::zhu::table::RequestLandlordType value);

  // optional uint32 nextPosition = 9;
  bool has_nextposition() const;
  void clear_nextposition();
  static const int kNextPositionFieldNumber = 9;
  ::google::protobuf::uint32 nextposition() const;
  void set_nextposition(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhu.table.RequestLandlordResp)
 private:
  void set_has_calllandlordresult();
  void clear_has_calllandlordresult();
  void set_has_desc();
  void clear_has_desc();
  void set_has_account();
  void clear_has_account();
  void set_has_currentposition();
  void clear_has_currentposition();
  void set_has_call();
  void clear_has_call();
  void set_has_type();
  void clear_has_type();
  void set_has_nexttype();
  void clear_has_nexttype();
  void set_has_next();
  void clear_has_next();
  void set_has_nextposition();
  void clear_has_nextposition();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr next_;
  int calllandlordresult_;
  ::google::protobuf::uint32 currentposition_;
  bool call_;
  int type_;
  int nexttype_;
  ::google::protobuf::uint32 nextposition_;
  friend struct protobuf_table_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DispatchPoker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.table.DispatchPoker) */ {
 public:
  DispatchPoker();
  virtual ~DispatchPoker();

  DispatchPoker(const DispatchPoker& from);

  inline DispatchPoker& operator=(const DispatchPoker& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DispatchPoker& default_instance();

  static inline const DispatchPoker* internal_default_instance() {
    return reinterpret_cast<const DispatchPoker*>(
               &_DispatchPoker_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DispatchPoker* other);

  // implements Message ----------------------------------------------

  inline DispatchPoker* New() const PROTOBUF_FINAL { return New(NULL); }

  DispatchPoker* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DispatchPoker& from);
  void MergeFrom(const DispatchPoker& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DispatchPoker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zhu.table.Poker pockers = 1;
  int pockers_size() const;
  void clear_pockers();
  static const int kPockersFieldNumber = 1;
  const ::zhu::table::Poker& pockers(int index) const;
  ::zhu::table::Poker* mutable_pockers(int index);
  ::zhu::table::Poker* add_pockers();
  ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker >*
      mutable_pockers();
  const ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker >&
      pockers() const;

  // optional bytes landlordAccount = 3;
  bool has_landlordaccount() const;
  void clear_landlordaccount();
  static const int kLandlordAccountFieldNumber = 3;
  const ::std::string& landlordaccount() const;
  void set_landlordaccount(const ::std::string& value);
  #if LANG_CXX11
  void set_landlordaccount(::std::string&& value);
  #endif
  void set_landlordaccount(const char* value);
  void set_landlordaccount(const void* value, size_t size);
  ::std::string* mutable_landlordaccount();
  ::std::string* release_landlordaccount();
  void set_allocated_landlordaccount(::std::string* landlordaccount);

  // required .zhu.table.DispatchPokerType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::zhu::table::DispatchPokerType type() const;
  void set_type(::zhu::table::DispatchPokerType value);

  // optional uint32 position = 4;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 4;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zhu.table.DispatchPoker)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_landlordaccount();
  void clear_has_landlordaccount();
  void set_has_position();
  void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker > pockers_;
  ::google::protobuf::internal::ArenaStringPtr landlordaccount_;
  int type_;
  ::google::protobuf::uint32 position_;
  friend struct protobuf_table_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayerOut : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zhu.table.PlayerOut) */ {
 public:
  PlayerOut();
  virtual ~PlayerOut();

  PlayerOut(const PlayerOut& from);

  inline PlayerOut& operator=(const PlayerOut& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerOut& default_instance();

  static inline const PlayerOut* internal_default_instance() {
    return reinterpret_cast<const PlayerOut*>(
               &_PlayerOut_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(PlayerOut* other);

  // implements Message ----------------------------------------------

  inline PlayerOut* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerOut* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerOut& from);
  void MergeFrom(const PlayerOut& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerOut* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const void* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // optional bytes account = 3;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 3;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const void* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // required .zhu.table.ERROR_CODE errorResult = 1;
  bool has_errorresult() const;
  void clear_errorresult();
  static const int kErrorResultFieldNumber = 1;
  ::zhu::table::ERROR_CODE errorresult() const;
  void set_errorresult(::zhu::table::ERROR_CODE value);

  // @@protoc_insertion_point(class_scope:zhu.table.PlayerOut)
 private:
  void set_has_errorresult();
  void clear_has_errorresult();
  void set_has_desc();
  void clear_has_desc();
  void set_has_account();
  void clear_has_account();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  int errorresult_;
  friend struct protobuf_table_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Poker

// required uint32 number = 1;
inline bool Poker::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Poker::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Poker::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Poker::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 Poker::number() const {
  // @@protoc_insertion_point(field_get:zhu.table.Poker.number)
  return number_;
}
inline void Poker::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.Poker.number)
}

// required int32 value = 2;
inline bool Poker::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Poker::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Poker::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Poker::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Poker::value() const {
  // @@protoc_insertion_point(field_get:zhu.table.Poker.value)
  return value_;
}
inline void Poker::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.Poker.value)
}

// required .zhu.table.POKER_SUIT suit = 3;
inline bool Poker::has_suit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Poker::set_has_suit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Poker::clear_has_suit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Poker::clear_suit() {
  suit_ = 0;
  clear_has_suit();
}
inline ::zhu::table::POKER_SUIT Poker::suit() const {
  // @@protoc_insertion_point(field_get:zhu.table.Poker.suit)
  return static_cast< ::zhu::table::POKER_SUIT >(suit_);
}
inline void Poker::set_suit(::zhu::table::POKER_SUIT value) {
  assert(::zhu::table::POKER_SUIT_IsValid(value));
  set_has_suit();
  suit_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.Poker.suit)
}

// -------------------------------------------------------------------

// PlayReq

// required uint32 roomId = 1;
inline bool PlayReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 PlayReq::roomid() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayReq.roomId)
  return roomid_;
}
inline void PlayReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.PlayReq.roomId)
}

// required bytes account = 2;
inline bool PlayReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayReq::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& PlayReq::account() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayReq.account)
  return account_.GetNoArena();
}
inline void PlayReq::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.PlayReq.account)
}
#if LANG_CXX11
inline void PlayReq::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.PlayReq.account)
}
#endif
inline void PlayReq::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.PlayReq.account)
}
inline void PlayReq::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.PlayReq.account)
}
inline ::std::string* PlayReq::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.table.PlayReq.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayReq::release_account() {
  // @@protoc_insertion_point(field_release:zhu.table.PlayReq.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayReq::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.PlayReq.account)
}

// required .zhu.table.PLAY_TYPE type = 3;
inline bool PlayReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::zhu::table::PLAY_TYPE PlayReq::type() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayReq.type)
  return static_cast< ::zhu::table::PLAY_TYPE >(type_);
}
inline void PlayReq::set_type(::zhu::table::PLAY_TYPE value) {
  assert(::zhu::table::PLAY_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.PlayReq.type)
}

// repeated .zhu.table.Poker pokers = 4;
inline int PlayReq::pokers_size() const {
  return pokers_.size();
}
inline void PlayReq::clear_pokers() {
  pokers_.Clear();
}
inline const ::zhu::table::Poker& PlayReq::pokers(int index) const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayReq.pokers)
  return pokers_.Get(index);
}
inline ::zhu::table::Poker* PlayReq::mutable_pokers(int index) {
  // @@protoc_insertion_point(field_mutable:zhu.table.PlayReq.pokers)
  return pokers_.Mutable(index);
}
inline ::zhu::table::Poker* PlayReq::add_pokers() {
  // @@protoc_insertion_point(field_add:zhu.table.PlayReq.pokers)
  return pokers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker >*
PlayReq::mutable_pokers() {
  // @@protoc_insertion_point(field_mutable_list:zhu.table.PlayReq.pokers)
  return &pokers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker >&
PlayReq::pokers() const {
  // @@protoc_insertion_point(field_list:zhu.table.PlayReq.pokers)
  return pokers_;
}

// -------------------------------------------------------------------

// PlayResp

// required .zhu.table.ERROR_CODE playResult = 1;
inline bool PlayResp::has_playresult() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayResp::set_has_playresult() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayResp::clear_has_playresult() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayResp::clear_playresult() {
  playresult_ = 0;
  clear_has_playresult();
}
inline ::zhu::table::ERROR_CODE PlayResp::playresult() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayResp.playResult)
  return static_cast< ::zhu::table::ERROR_CODE >(playresult_);
}
inline void PlayResp::set_playresult(::zhu::table::ERROR_CODE value) {
  assert(::zhu::table::ERROR_CODE_IsValid(value));
  set_has_playresult();
  playresult_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.PlayResp.playResult)
}

// optional bytes desc = 2;
inline bool PlayResp::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayResp::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayResp::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayResp::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& PlayResp::desc() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayResp.desc)
  return desc_.GetNoArena();
}
inline void PlayResp::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.PlayResp.desc)
}
#if LANG_CXX11
inline void PlayResp::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.PlayResp.desc)
}
#endif
inline void PlayResp::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.PlayResp.desc)
}
inline void PlayResp::set_desc(const void* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.PlayResp.desc)
}
inline ::std::string* PlayResp::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:zhu.table.PlayResp.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayResp::release_desc() {
  // @@protoc_insertion_point(field_release:zhu.table.PlayResp.desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayResp::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.PlayResp.desc)
}

// optional bytes account = 3;
inline bool PlayResp::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayResp::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayResp::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayResp::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& PlayResp::account() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayResp.account)
  return account_.GetNoArena();
}
inline void PlayResp::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.PlayResp.account)
}
#if LANG_CXX11
inline void PlayResp::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.PlayResp.account)
}
#endif
inline void PlayResp::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.PlayResp.account)
}
inline void PlayResp::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.PlayResp.account)
}
inline ::std::string* PlayResp::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.table.PlayResp.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayResp::release_account() {
  // @@protoc_insertion_point(field_release:zhu.table.PlayResp.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayResp::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.PlayResp.account)
}

// optional bytes next = 4;
inline bool PlayResp::has_next() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayResp::set_has_next() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayResp::clear_has_next() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayResp::clear_next() {
  next_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_next();
}
inline const ::std::string& PlayResp::next() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayResp.next)
  return next_.GetNoArena();
}
inline void PlayResp::set_next(const ::std::string& value) {
  set_has_next();
  next_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.PlayResp.next)
}
#if LANG_CXX11
inline void PlayResp::set_next(::std::string&& value) {
  set_has_next();
  next_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.PlayResp.next)
}
#endif
inline void PlayResp::set_next(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_next();
  next_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.PlayResp.next)
}
inline void PlayResp::set_next(const void* value, size_t size) {
  set_has_next();
  next_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.PlayResp.next)
}
inline ::std::string* PlayResp::mutable_next() {
  set_has_next();
  // @@protoc_insertion_point(field_mutable:zhu.table.PlayResp.next)
  return next_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayResp::release_next() {
  // @@protoc_insertion_point(field_release:zhu.table.PlayResp.next)
  clear_has_next();
  return next_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayResp::set_allocated_next(::std::string* next) {
  if (next != NULL) {
    set_has_next();
  } else {
    clear_has_next();
  }
  next_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.PlayResp.next)
}

// optional uint32 nextPosition = 5;
inline bool PlayResp::has_nextposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayResp::set_has_nextposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayResp::clear_has_nextposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayResp::clear_nextposition() {
  nextposition_ = 0u;
  clear_has_nextposition();
}
inline ::google::protobuf::uint32 PlayResp::nextposition() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayResp.nextPosition)
  return nextposition_;
}
inline void PlayResp::set_nextposition(::google::protobuf::uint32 value) {
  set_has_nextposition();
  nextposition_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.PlayResp.nextPosition)
}

// optional uint32 currentPosition = 6;
inline bool PlayResp::has_currentposition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayResp::set_has_currentposition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayResp::clear_has_currentposition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayResp::clear_currentposition() {
  currentposition_ = 0u;
  clear_has_currentposition();
}
inline ::google::protobuf::uint32 PlayResp::currentposition() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayResp.currentPosition)
  return currentposition_;
}
inline void PlayResp::set_currentposition(::google::protobuf::uint32 value) {
  set_has_currentposition();
  currentposition_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.PlayResp.currentPosition)
}

// optional uint32 number = 7;
inline bool PlayResp::has_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayResp::set_has_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayResp::clear_has_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayResp::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 PlayResp::number() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayResp.number)
  return number_;
}
inline void PlayResp::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.PlayResp.number)
}

// -------------------------------------------------------------------

// RequestLandlordReq

// required uint32 roomId = 1;
inline bool RequestLandlordReq::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestLandlordReq::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestLandlordReq::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestLandlordReq::clear_roomid() {
  roomid_ = 0u;
  clear_has_roomid();
}
inline ::google::protobuf::uint32 RequestLandlordReq::roomid() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordReq.roomId)
  return roomid_;
}
inline void RequestLandlordReq::set_roomid(::google::protobuf::uint32 value) {
  set_has_roomid();
  roomid_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordReq.roomId)
}

// required bytes account = 2;
inline bool RequestLandlordReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestLandlordReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestLandlordReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestLandlordReq::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& RequestLandlordReq::account() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordReq.account)
  return account_.GetNoArena();
}
inline void RequestLandlordReq::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordReq.account)
}
#if LANG_CXX11
inline void RequestLandlordReq::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.RequestLandlordReq.account)
}
#endif
inline void RequestLandlordReq::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.RequestLandlordReq.account)
}
inline void RequestLandlordReq::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.RequestLandlordReq.account)
}
inline ::std::string* RequestLandlordReq::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.table.RequestLandlordReq.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestLandlordReq::release_account() {
  // @@protoc_insertion_point(field_release:zhu.table.RequestLandlordReq.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestLandlordReq::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.RequestLandlordReq.account)
}

// required bool call = 3;
inline bool RequestLandlordReq::has_call() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestLandlordReq::set_has_call() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestLandlordReq::clear_has_call() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestLandlordReq::clear_call() {
  call_ = false;
  clear_has_call();
}
inline bool RequestLandlordReq::call() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordReq.call)
  return call_;
}
inline void RequestLandlordReq::set_call(bool value) {
  set_has_call();
  call_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordReq.call)
}

// optional .zhu.table.RequestLandlordType type = 4;
inline bool RequestLandlordReq::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestLandlordReq::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestLandlordReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestLandlordReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::zhu::table::RequestLandlordType RequestLandlordReq::type() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordReq.type)
  return static_cast< ::zhu::table::RequestLandlordType >(type_);
}
inline void RequestLandlordReq::set_type(::zhu::table::RequestLandlordType value) {
  assert(::zhu::table::RequestLandlordType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordReq.type)
}

// -------------------------------------------------------------------

// RequestLandlordResp

// required .zhu.table.ERROR_CODE callLandlordResult = 1;
inline bool RequestLandlordResp::has_calllandlordresult() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestLandlordResp::set_has_calllandlordresult() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestLandlordResp::clear_has_calllandlordresult() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestLandlordResp::clear_calllandlordresult() {
  calllandlordresult_ = 0;
  clear_has_calllandlordresult();
}
inline ::zhu::table::ERROR_CODE RequestLandlordResp::calllandlordresult() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordResp.callLandlordResult)
  return static_cast< ::zhu::table::ERROR_CODE >(calllandlordresult_);
}
inline void RequestLandlordResp::set_calllandlordresult(::zhu::table::ERROR_CODE value) {
  assert(::zhu::table::ERROR_CODE_IsValid(value));
  set_has_calllandlordresult();
  calllandlordresult_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordResp.callLandlordResult)
}

// optional bytes desc = 2;
inline bool RequestLandlordResp::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestLandlordResp::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestLandlordResp::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestLandlordResp::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& RequestLandlordResp::desc() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordResp.desc)
  return desc_.GetNoArena();
}
inline void RequestLandlordResp::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordResp.desc)
}
#if LANG_CXX11
inline void RequestLandlordResp::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.RequestLandlordResp.desc)
}
#endif
inline void RequestLandlordResp::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.RequestLandlordResp.desc)
}
inline void RequestLandlordResp::set_desc(const void* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.RequestLandlordResp.desc)
}
inline ::std::string* RequestLandlordResp::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:zhu.table.RequestLandlordResp.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestLandlordResp::release_desc() {
  // @@protoc_insertion_point(field_release:zhu.table.RequestLandlordResp.desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestLandlordResp::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.RequestLandlordResp.desc)
}

// optional bytes account = 3;
inline bool RequestLandlordResp::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestLandlordResp::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestLandlordResp::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestLandlordResp::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& RequestLandlordResp::account() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordResp.account)
  return account_.GetNoArena();
}
inline void RequestLandlordResp::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordResp.account)
}
#if LANG_CXX11
inline void RequestLandlordResp::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.RequestLandlordResp.account)
}
#endif
inline void RequestLandlordResp::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.RequestLandlordResp.account)
}
inline void RequestLandlordResp::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.RequestLandlordResp.account)
}
inline ::std::string* RequestLandlordResp::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.table.RequestLandlordResp.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestLandlordResp::release_account() {
  // @@protoc_insertion_point(field_release:zhu.table.RequestLandlordResp.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestLandlordResp::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.RequestLandlordResp.account)
}

// optional uint32 currentPosition = 4;
inline bool RequestLandlordResp::has_currentposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestLandlordResp::set_has_currentposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestLandlordResp::clear_has_currentposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestLandlordResp::clear_currentposition() {
  currentposition_ = 0u;
  clear_has_currentposition();
}
inline ::google::protobuf::uint32 RequestLandlordResp::currentposition() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordResp.currentPosition)
  return currentposition_;
}
inline void RequestLandlordResp::set_currentposition(::google::protobuf::uint32 value) {
  set_has_currentposition();
  currentposition_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordResp.currentPosition)
}

// optional bool call = 5;
inline bool RequestLandlordResp::has_call() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestLandlordResp::set_has_call() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestLandlordResp::clear_has_call() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestLandlordResp::clear_call() {
  call_ = false;
  clear_has_call();
}
inline bool RequestLandlordResp::call() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordResp.call)
  return call_;
}
inline void RequestLandlordResp::set_call(bool value) {
  set_has_call();
  call_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordResp.call)
}

// optional .zhu.table.RequestLandlordType type = 6;
inline bool RequestLandlordResp::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestLandlordResp::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestLandlordResp::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestLandlordResp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::zhu::table::RequestLandlordType RequestLandlordResp::type() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordResp.type)
  return static_cast< ::zhu::table::RequestLandlordType >(type_);
}
inline void RequestLandlordResp::set_type(::zhu::table::RequestLandlordType value) {
  assert(::zhu::table::RequestLandlordType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordResp.type)
}

// optional .zhu.table.RequestLandlordType nextType = 7;
inline bool RequestLandlordResp::has_nexttype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestLandlordResp::set_has_nexttype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestLandlordResp::clear_has_nexttype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestLandlordResp::clear_nexttype() {
  nexttype_ = 0;
  clear_has_nexttype();
}
inline ::zhu::table::RequestLandlordType RequestLandlordResp::nexttype() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordResp.nextType)
  return static_cast< ::zhu::table::RequestLandlordType >(nexttype_);
}
inline void RequestLandlordResp::set_nexttype(::zhu::table::RequestLandlordType value) {
  assert(::zhu::table::RequestLandlordType_IsValid(value));
  set_has_nexttype();
  nexttype_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordResp.nextType)
}

// optional bytes next = 8;
inline bool RequestLandlordResp::has_next() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestLandlordResp::set_has_next() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestLandlordResp::clear_has_next() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestLandlordResp::clear_next() {
  next_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_next();
}
inline const ::std::string& RequestLandlordResp::next() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordResp.next)
  return next_.GetNoArena();
}
inline void RequestLandlordResp::set_next(const ::std::string& value) {
  set_has_next();
  next_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordResp.next)
}
#if LANG_CXX11
inline void RequestLandlordResp::set_next(::std::string&& value) {
  set_has_next();
  next_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.RequestLandlordResp.next)
}
#endif
inline void RequestLandlordResp::set_next(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_next();
  next_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.RequestLandlordResp.next)
}
inline void RequestLandlordResp::set_next(const void* value, size_t size) {
  set_has_next();
  next_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.RequestLandlordResp.next)
}
inline ::std::string* RequestLandlordResp::mutable_next() {
  set_has_next();
  // @@protoc_insertion_point(field_mutable:zhu.table.RequestLandlordResp.next)
  return next_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestLandlordResp::release_next() {
  // @@protoc_insertion_point(field_release:zhu.table.RequestLandlordResp.next)
  clear_has_next();
  return next_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestLandlordResp::set_allocated_next(::std::string* next) {
  if (next != NULL) {
    set_has_next();
  } else {
    clear_has_next();
  }
  next_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.RequestLandlordResp.next)
}

// optional uint32 nextPosition = 9;
inline bool RequestLandlordResp::has_nextposition() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestLandlordResp::set_has_nextposition() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestLandlordResp::clear_has_nextposition() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestLandlordResp::clear_nextposition() {
  nextposition_ = 0u;
  clear_has_nextposition();
}
inline ::google::protobuf::uint32 RequestLandlordResp::nextposition() const {
  // @@protoc_insertion_point(field_get:zhu.table.RequestLandlordResp.nextPosition)
  return nextposition_;
}
inline void RequestLandlordResp::set_nextposition(::google::protobuf::uint32 value) {
  set_has_nextposition();
  nextposition_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.RequestLandlordResp.nextPosition)
}

// -------------------------------------------------------------------

// DispatchPoker

// repeated .zhu.table.Poker pockers = 1;
inline int DispatchPoker::pockers_size() const {
  return pockers_.size();
}
inline void DispatchPoker::clear_pockers() {
  pockers_.Clear();
}
inline const ::zhu::table::Poker& DispatchPoker::pockers(int index) const {
  // @@protoc_insertion_point(field_get:zhu.table.DispatchPoker.pockers)
  return pockers_.Get(index);
}
inline ::zhu::table::Poker* DispatchPoker::mutable_pockers(int index) {
  // @@protoc_insertion_point(field_mutable:zhu.table.DispatchPoker.pockers)
  return pockers_.Mutable(index);
}
inline ::zhu::table::Poker* DispatchPoker::add_pockers() {
  // @@protoc_insertion_point(field_add:zhu.table.DispatchPoker.pockers)
  return pockers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker >*
DispatchPoker::mutable_pockers() {
  // @@protoc_insertion_point(field_mutable_list:zhu.table.DispatchPoker.pockers)
  return &pockers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zhu::table::Poker >&
DispatchPoker::pockers() const {
  // @@protoc_insertion_point(field_list:zhu.table.DispatchPoker.pockers)
  return pockers_;
}

// required .zhu.table.DispatchPokerType type = 2;
inline bool DispatchPoker::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DispatchPoker::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DispatchPoker::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DispatchPoker::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::zhu::table::DispatchPokerType DispatchPoker::type() const {
  // @@protoc_insertion_point(field_get:zhu.table.DispatchPoker.type)
  return static_cast< ::zhu::table::DispatchPokerType >(type_);
}
inline void DispatchPoker::set_type(::zhu::table::DispatchPokerType value) {
  assert(::zhu::table::DispatchPokerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.DispatchPoker.type)
}

// optional bytes landlordAccount = 3;
inline bool DispatchPoker::has_landlordaccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DispatchPoker::set_has_landlordaccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DispatchPoker::clear_has_landlordaccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DispatchPoker::clear_landlordaccount() {
  landlordaccount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_landlordaccount();
}
inline const ::std::string& DispatchPoker::landlordaccount() const {
  // @@protoc_insertion_point(field_get:zhu.table.DispatchPoker.landlordAccount)
  return landlordaccount_.GetNoArena();
}
inline void DispatchPoker::set_landlordaccount(const ::std::string& value) {
  set_has_landlordaccount();
  landlordaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.DispatchPoker.landlordAccount)
}
#if LANG_CXX11
inline void DispatchPoker::set_landlordaccount(::std::string&& value) {
  set_has_landlordaccount();
  landlordaccount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.DispatchPoker.landlordAccount)
}
#endif
inline void DispatchPoker::set_landlordaccount(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_landlordaccount();
  landlordaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.DispatchPoker.landlordAccount)
}
inline void DispatchPoker::set_landlordaccount(const void* value, size_t size) {
  set_has_landlordaccount();
  landlordaccount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.DispatchPoker.landlordAccount)
}
inline ::std::string* DispatchPoker::mutable_landlordaccount() {
  set_has_landlordaccount();
  // @@protoc_insertion_point(field_mutable:zhu.table.DispatchPoker.landlordAccount)
  return landlordaccount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DispatchPoker::release_landlordaccount() {
  // @@protoc_insertion_point(field_release:zhu.table.DispatchPoker.landlordAccount)
  clear_has_landlordaccount();
  return landlordaccount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DispatchPoker::set_allocated_landlordaccount(::std::string* landlordaccount) {
  if (landlordaccount != NULL) {
    set_has_landlordaccount();
  } else {
    clear_has_landlordaccount();
  }
  landlordaccount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), landlordaccount);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.DispatchPoker.landlordAccount)
}

// optional uint32 position = 4;
inline bool DispatchPoker::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DispatchPoker::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DispatchPoker::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DispatchPoker::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 DispatchPoker::position() const {
  // @@protoc_insertion_point(field_get:zhu.table.DispatchPoker.position)
  return position_;
}
inline void DispatchPoker::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.DispatchPoker.position)
}

// -------------------------------------------------------------------

// PlayerOut

// required .zhu.table.ERROR_CODE errorResult = 1;
inline bool PlayerOut::has_errorresult() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerOut::set_has_errorresult() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerOut::clear_has_errorresult() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerOut::clear_errorresult() {
  errorresult_ = 0;
  clear_has_errorresult();
}
inline ::zhu::table::ERROR_CODE PlayerOut::errorresult() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayerOut.errorResult)
  return static_cast< ::zhu::table::ERROR_CODE >(errorresult_);
}
inline void PlayerOut::set_errorresult(::zhu::table::ERROR_CODE value) {
  assert(::zhu::table::ERROR_CODE_IsValid(value));
  set_has_errorresult();
  errorresult_ = value;
  // @@protoc_insertion_point(field_set:zhu.table.PlayerOut.errorResult)
}

// optional bytes desc = 2;
inline bool PlayerOut::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerOut::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerOut::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerOut::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& PlayerOut::desc() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayerOut.desc)
  return desc_.GetNoArena();
}
inline void PlayerOut::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.PlayerOut.desc)
}
#if LANG_CXX11
inline void PlayerOut::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.PlayerOut.desc)
}
#endif
inline void PlayerOut::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.PlayerOut.desc)
}
inline void PlayerOut::set_desc(const void* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.PlayerOut.desc)
}
inline ::std::string* PlayerOut::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:zhu.table.PlayerOut.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerOut::release_desc() {
  // @@protoc_insertion_point(field_release:zhu.table.PlayerOut.desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerOut::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.PlayerOut.desc)
}

// optional bytes account = 3;
inline bool PlayerOut::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerOut::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerOut::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerOut::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& PlayerOut::account() const {
  // @@protoc_insertion_point(field_get:zhu.table.PlayerOut.account)
  return account_.GetNoArena();
}
inline void PlayerOut::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zhu.table.PlayerOut.account)
}
#if LANG_CXX11
inline void PlayerOut::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zhu.table.PlayerOut.account)
}
#endif
inline void PlayerOut::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zhu.table.PlayerOut.account)
}
inline void PlayerOut::set_account(const void* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zhu.table.PlayerOut.account)
}
inline ::std::string* PlayerOut::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:zhu.table.PlayerOut.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerOut::release_account() {
  // @@protoc_insertion_point(field_release:zhu.table.PlayerOut.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerOut::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:zhu.table.PlayerOut.account)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace table
}  // namespace zhu

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zhu::table::POKER_SUIT> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zhu::table::POKER_SUIT>() {
  return ::zhu::table::POKER_SUIT_descriptor();
}
template <> struct is_proto_enum< ::zhu::table::PLAY_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zhu::table::PLAY_TYPE>() {
  return ::zhu::table::PLAY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::zhu::table::ERROR_CODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zhu::table::ERROR_CODE>() {
  return ::zhu::table::ERROR_CODE_descriptor();
}
template <> struct is_proto_enum< ::zhu::table::RequestLandlordType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zhu::table::RequestLandlordType>() {
  return ::zhu::table::RequestLandlordType_descriptor();
}
template <> struct is_proto_enum< ::zhu::table::DispatchPokerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zhu::table::DispatchPokerType>() {
  return ::zhu::table::DispatchPokerType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_table_2eproto__INCLUDED
